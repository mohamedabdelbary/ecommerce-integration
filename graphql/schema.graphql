# !IMPORTANT! This schema was auto-generated by pasting the output of the below query

#fragment FullType on __Type {
#    kind
#    name
#    fields(includeDeprecated: true) {
#        name
#        args {
#            ...InputValue
#        }
#        type {
#            ...TypeRef
#        }
#        isDeprecated
#        deprecationReason
#    }
#    inputFields {
#        ...InputValue
#    }
#    interfaces {
#        ...TypeRef
#    }
#    enumValues(includeDeprecated: true) {
#        name
#        isDeprecated
#        deprecationReason
#    }
#    possibleTypes {
#        ...TypeRef
#    }
#}
#fragment InputValue on __InputValue {
#    name
#    type {
#        ...TypeRef
#    }
#    defaultValue
#}
#fragment TypeRef on __Type {
#    kind
#    name
#    ofType {
#        kind
#        name
#        ofType {
#            kind
#            name
#            ofType {
#                kind
#                name
#                ofType {
#                    kind
#                    name
#                    ofType {
#                        kind
#                        name
#                        ofType {
#                            kind
#                            name
#                            ofType {
#                                kind
#                                name
#                            }
#                        }
#                    }
#                }
#            }
#        }
#    }
#}
#query IntrospectionQuery {
#    __schema {
#        queryType {
#            name
#        }
#        mutationType {
#            name
#        }
#        types {
#            ...FullType
#        }
#        directives {
#            name
#            locations
#            args {
#                ...InputValue
#            }
#        }
#    }
#}

#into https://codesandbox.io/s/graphql-introspection-sdl-svlx2

schema {
    query: QueryRoot
    mutation: Mutation
}

directive @accessRestricted(reason: String = null) on FIELD_DEFINITION | OBJECT

type AccessScope {
    description: String!
    handle: String!
}

type AdjustmentSale implements Sale {
    actionType: SaleActionType!
    id: ID!
    lineType: SaleLineType!
    quantity: Int
    taxes: [SaleTax!]!
    totalAmount: MoneyBag!
    totalDiscountAmountAfterTaxes: MoneyBag!
    totalDiscountAmountBeforeTaxes: MoneyBag!
    totalTaxAmount: MoneyBag!
}

type AllDiscountItems {
    allItems: Boolean!
}

type ApiVersion {
    displayName: String!
    handle: String!
    supported: Boolean!
}

type App implements Node {
    apiKey: String!
    appStoreAppUrl: URL
    appStoreDeveloperUrl: URL
    banner: Image!
    description: String
    developerName: String
    developerUrl: URL! @deprecated(reason: "Use `appStoreDeveloperUrl` instead")
    embedded: Boolean!
    failedRequirements: [FailedRequirement!]!
    features: [String!]!
    feedback: AppFeedback
    handle: String
    icon: Image!
    id: ID!
    installUrl: URL
    installation: AppInstallation
    launchUrl: URL! @deprecated(reason: "Use AppInstallation.launchUrl instead")
    navigationItems: [NavigationItem!]! @deprecated(reason: "Use AppInstallation.navigationItems instead")
    pricingDetails: String
    pricingDetailsSummary: String!
    privacyPolicyUrl: URL
    published: Boolean!
    screenshots: [Image!]!
    shopifyDeveloped: Boolean!
    title: String!
    uninstallMessage: String!
    uninstallUrl: URL @deprecated(reason: "Use AppInstallation.uninstallUrl instead")
}

type AppConnection {
    edges: [AppEdge!]!
    pageInfo: PageInfo!
}

type AppCredit implements Node {
    amount: MoneyV2!
    createdAt: DateTime!
    description: String!
    id: ID!
    test: Boolean!
}

type AppCreditConnection {
    edges: [AppCreditEdge!]!
    pageInfo: PageInfo!
}

type AppCreditCreatePayload {
    appCredit: AppCredit
    userErrors: [UserError!]!
}

type AppCreditEdge {
    cursor: String!
    node: AppCredit!
}

type AppEdge {
    cursor: String!
    node: App!
}

type AppFeedback {
    app: App!
    link: Link
    messages: [UserError!]!
}

type AppInstallation implements Node {
    accessScopes: [AccessScope!]!
    activeSubscriptions: [AppSubscription!]!
    allSubscriptions(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AppSubscriptionSortKeys = CREATED_AT): AppSubscriptionConnection!
    app: App!
    channel: Channel @deprecated(reason: "Use `publication` instead")
    credits(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AppTransactionSortKeys = CREATED_AT): AppCreditConnection!
    id: ID!
    launchUrl: URL!
    oneTimePurchases(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AppTransactionSortKeys = CREATED_AT): AppPurchaseOneTimeConnection!
    publication: Publication
    revenueAttributionRecords(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AppRevenueAttributionRecordSortKeys = CREATED_AT): AppRevenueAttributionRecordConnection!
    subscriptions: [AppSubscription!]! @deprecated(reason: "Use `activeSubscriptions` instead")
    uninstallUrl: URL
}

enum AppInstallationCategory {
    CHANNEL
    POS_EMBEDDED
}

type AppInstallationConnection {
    edges: [AppInstallationEdge!]!
    pageInfo: PageInfo!
}

type AppInstallationEdge {
    cursor: String!
    node: AppInstallation!
}

enum AppInstallationPrivacy {
    PUBLIC
    PRIVATE
}

enum AppInstallationSortKeys {
    INSTALLED_AT
    APP_TITLE
    ID
    RELEVANCE
}

input AppPlanInput {
    appUsagePricingDetails: AppUsagePricingInput
    appRecurringPricingDetails: AppRecurringPricingInput
}

type AppPlanV2 {
    pricingDetails: AppPricingDetails!
}

union AppPricingDetails = AppRecurringPricing | AppUsagePricing

enum AppPricingInterval {
    ANNUAL
    EVERY_30_DAYS
}

interface AppPurchase {
    createdAt: DateTime!
    name: String!
    price: MoneyV2!
    status: AppPurchaseStatus!
    test: Boolean!
}

type AppPurchaseOneTime implements AppPurchase & Node {
    createdAt: DateTime!
    id: ID!
    name: String!
    price: MoneyV2!
    status: AppPurchaseStatus!
    test: Boolean!
}

type AppPurchaseOneTimeConnection {
    edges: [AppPurchaseOneTimeEdge!]!
    pageInfo: PageInfo!
}

type AppPurchaseOneTimeCreatePayload {
    appPurchaseOneTime: AppPurchaseOneTime
    confirmationUrl: URL
    userErrors: [UserError!]!
}

type AppPurchaseOneTimeEdge {
    cursor: String!
    node: AppPurchaseOneTime!
}

enum AppPurchaseStatus {
    ACCEPTED
    ACTIVE
    DECLINED
    EXPIRED
    PENDING
}

type AppRecurringPricing {
    interval: AppPricingInterval!
    price: MoneyV2!
}

input AppRecurringPricingInput {
    interval: AppPricingInterval = EVERY_30_DAYS
    price: MoneyInput!
}

type AppRevenueAttributionRecord implements Node {
    amount: MoneyV2!
    capturedAt: DateTime!
    createdAt: DateTime!
    id: ID!
    idempotencyKey: String!
    test: Boolean!
    type: AppRevenueAttributionType!
}

type AppRevenueAttributionRecordConnection {
    edges: [AppRevenueAttributionRecordEdge!]!
    pageInfo: PageInfo!
}

type AppRevenueAttributionRecordCreatePayload {
    appRevenueAttributionRecord: AppRevenueAttributionRecord
    userErrors: [AppRevenueAttributionRecordCreateUserError!]!
}

type AppRevenueAttributionRecordCreateUserError implements DisplayableError {
    code: AppRevenueAttributionRecordCreateUserErrorCode
    field: [String!]
    message: String!
}

enum AppRevenueAttributionRecordCreateUserErrorCode {
    INVALID
    TAKEN
}

type AppRevenueAttributionRecordDeletePayload {
    deletedId: ID
    userErrors: [AppRevenueAttributionRecordDeleteUserError!]!
}

type AppRevenueAttributionRecordDeleteUserError implements DisplayableError {
    code: AppRevenueAttributionRecordDeleteUserErrorCode
    field: [String!]
    message: String!
}

enum AppRevenueAttributionRecordDeleteUserErrorCode {
    INVALID
}

type AppRevenueAttributionRecordEdge {
    cursor: String!
    node: AppRevenueAttributionRecord!
}

input AppRevenueAttributionRecordInput {
    idempotencyKey: String!
    capturedAt: DateTime!
    amount: MoneyInput!
    type: AppRevenueAttributionType!
    test: Boolean!
}

enum AppRevenueAttributionRecordSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

enum AppRevenueAttributionType {
    APPLICATION_PURCHASE
    APPLICATION_SUBSCRIPTION
    APPLICATION_USAGE
    OTHER
}

type AppSubscription implements Node {
    createdAt: DateTime!
    currentPeriodEnd: DateTime
    id: ID!
    lineItems: [AppSubscriptionLineItem!]!
    name: String!
    returnUrl: URL!
    status: AppSubscriptionStatus!
    test: Boolean!
    trialDays: Int!
}

type AppSubscriptionCancelPayload {
    appSubscription: AppSubscription
    userErrors: [UserError!]!
}

type AppSubscriptionConnection {
    edges: [AppSubscriptionEdge!]!
    pageInfo: PageInfo!
}

type AppSubscriptionCreatePayload {
    appSubscription: AppSubscription
    confirmationUrl: URL
    userErrors: [UserError!]!
}

type AppSubscriptionEdge {
    cursor: String!
    node: AppSubscription!
}

type AppSubscriptionLineItem {
    id: ID!
    plan: AppPlanV2!
    usageRecords(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AppUsageRecordSortKeys = CREATED_AT): AppUsageRecordConnection!
}

input AppSubscriptionLineItemInput {
    plan: AppPlanInput!
}

type AppSubscriptionLineItemUpdatePayload {
    appSubscription: AppSubscription
    confirmationUrl: URL
    userErrors: [UserError!]!
}

enum AppSubscriptionSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

enum AppSubscriptionStatus {
    PENDING
    ACCEPTED
    ACTIVE
    DECLINED
    EXPIRED
    FROZEN
    CANCELLED
}

enum AppTransactionSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

type AppUsagePricing {
    balanceUsed: MoneyV2!
    cappedAmount: MoneyV2!
    interval: AppPricingInterval!
    terms: String!
}

input AppUsagePricingInput {
    cappedAmount: MoneyInput!
    terms: String!
}

type AppUsageRecord implements Node {
    createdAt: DateTime!
    description: String!
    id: ID!
    price: MoneyV2!
    subscriptionLineItem: AppSubscriptionLineItem!
}

type AppUsageRecordConnection {
    edges: [AppUsageRecordEdge!]!
    pageInfo: PageInfo!
}

type AppUsageRecordCreatePayload {
    appUsageRecord: AppUsageRecord
    userErrors: [UserError!]!
}

type AppUsageRecordEdge {
    cursor: String!
    node: AppUsageRecord!
}

enum AppUsageRecordSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

scalar ARN

type Attribute {
    key: String!
    value: String
}

input AttributeInput {
    key: String!
    value: String!
}

type AutomaticDiscountApplication implements DiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    index: Int!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    title: String!
    value: PricingValue!
}

enum AutomaticDiscountSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

type BasicEvent implements Node & Event {
    appTitle: String
    attributeToApp: Boolean!
    attributeToUser: Boolean!
    createdAt: DateTime!
    criticalAlert: Boolean!
    id: ID!
    message: FormattedString!
}

type BillingAttemptUserError implements DisplayableError {
    code: BillingAttemptUserErrorCode
    field: [String!]
    message: String!
}

enum BillingAttemptUserErrorCode {
    INVALID
    BLANK
    CONTRACT_NOT_FOUND
}

enum BulkMutationErrorCode {
    BULK_MUTATION_USER_ERROR_CODE
}

type BulkMutationUserError implements DisplayableError {
    code: BulkMutationErrorCode
    field: [String!]
    message: String!
}

type BulkOperation implements Node {
    completedAt: DateTime
    createdAt: DateTime!
    errorCode: BulkOperationErrorCode
    fileSize: UnsignedInt64
    id: ID!
    objectCount: UnsignedInt64!
    partialDataUrl: URL
    query: String!
    rootObjectCount: UnsignedInt64!
    status: BulkOperationStatus!
    url: URL
}

type BulkOperationCancelPayload {
    bulkOperation: BulkOperation
    userErrors: [UserError!]!
}

enum BulkOperationErrorCode {
    ACCESS_DENIED
    INTERNAL_SERVER_ERROR
    TIMEOUT
}

type BulkOperationRunMutationPayload {
    bulkOperation: BulkOperation
    userErrors: [BulkMutationUserError!]!
}

type BulkOperationRunQueryPayload {
    bulkOperation: BulkOperation
    userErrors: [UserError!]!
}

enum BulkOperationStatus {
    CREATED
    RUNNING
    COMPLETED
    CANCELING
    CANCELED
    FAILED
    EXPIRED
}

enum BulkOperationType {
    QUERY
    MUTATION
}

type CalculatedAutomaticDiscountApplication implements CalculatedDiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    appliedTo: DiscountApplicationLevel!
    description: String
    id: ID!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    value: PricingValue!
}

type CalculatedDiscountAllocation {
    allocatedAmountSet: MoneyBag!
    discountApplication: CalculatedDiscountApplication!
}

interface CalculatedDiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    appliedTo: DiscountApplicationLevel!
    description: String
    id: ID!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    value: PricingValue!
}

type CalculatedDiscountApplicationConnection {
    edges: [CalculatedDiscountApplicationEdge!]!
    pageInfo: PageInfo!
}

type CalculatedDiscountApplicationEdge {
    cursor: String!
    node: CalculatedDiscountApplication!
}

type CalculatedDiscountCodeApplication implements CalculatedDiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    appliedTo: DiscountApplicationLevel!
    code: String!
    description: String
    id: ID!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    value: PricingValue!
}

type CalculatedDraftOrder {
    appliedDiscount: DraftOrderAppliedDiscount
    availableShippingRates: [ShippingRate!]!
    customer: Customer
    lineItems: [CalculatedDraftOrderLineItem!]!
    shippingLine: ShippingLine
    subtotalPrice: Money!
    taxLines: [TaxLine!]!
    totalPrice: Money!
    totalShippingPrice: Money!
    totalTax: Money!
}

type CalculatedDraftOrderLineItem {
    appliedDiscount: DraftOrderAppliedDiscount
    custom: Boolean!
    customAttributes: [Attribute!]!
    discountedTotal: MoneyV2!
    discountedUnitPrice: MoneyV2!
    fulfillmentService: FulfillmentService!
    image: Image
    isGiftCard: Boolean!
    name: String!
    originalTotal: MoneyV2!
    originalUnitPrice: MoneyV2!
    product: Product
    quantity: Int!
    requiresShipping: Boolean!
    sku: String
    taxable: Boolean!
    title: String!
    totalDiscount: MoneyV2!
    variant: ProductVariant
    variantTitle: String
    vendor: String
    weight: Weight
}

type CalculatedLineItem {
    calculatedDiscountAllocations: [CalculatedDiscountAllocation!]!
    customAttributes: [Attribute!]!
    discountAllocations: [DiscountAllocation!]! @deprecated(reason: "Use `calculatedDiscountAllocations` instead")
    discountedUnitPriceSet: MoneyBag!
    editableQuantity: Int!
    editableQuantityBeforeChanges: Int!
    editableSubtotalSet: MoneyBag!
    hasStagedLineItemDiscount: Boolean!
    id: ID!
    image: Image
    originalUnitPriceSet: MoneyBag!
    quantity: Int!
    restockable: Boolean!
    restocking: Boolean!
    sku: String
    stagedChanges: [OrderStagedChange!]!
    title: String!
    uneditableSubtotalSet: MoneyBag!
    variant: ProductVariant
    variantTitle: String
}

type CalculatedLineItemConnection {
    edges: [CalculatedLineItemEdge!]!
    pageInfo: PageInfo!
}

type CalculatedLineItemEdge {
    cursor: String!
    node: CalculatedLineItem!
}

type CalculatedManualDiscountApplication implements CalculatedDiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    appliedTo: DiscountApplicationLevel!
    description: String
    id: ID!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    value: PricingValue!
}

type CalculatedOrder implements Node {
    addedDiscountApplications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CalculatedDiscountApplicationConnection!
    addedLineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CalculatedLineItemConnection!
    cartDiscountAmountSet: MoneyBag
    committed: Boolean!
    id: ID!
    lineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): CalculatedLineItemConnection!
    notificationPreviewHtml: HTML
    notificationPreviewTitle: String!
    order: Order! @deprecated(reason: "Use `originalOrder` instead")
    originalOrder: Order!
    stagedChanges(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): OrderStagedChangeConnection!
    subtotalLineItemsQuantity: Int!
    subtotalPriceSet: MoneyBag
    taxLines: [TaxLine!]!
    totalOutstandingSet: MoneyBag!
    totalPriceSet: MoneyBag!
}

type CalculatedScriptDiscountApplication implements CalculatedDiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    appliedTo: DiscountApplicationLevel!
    description: String
    id: ID!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    value: PricingValue!
}

type CaptureSession {
    id: ID!
    status: CaptureSessionStatus!
}

input CaptureSessionRejectionReasonInput {
    code: CaptureSessionStatusReasonRejectionCode!
    merchantMessage: String
}

type CaptureSessionRejectPayload {
    captureSession: CaptureSession
    userErrors: [CaptureSessionRejectUserError!]!
}

type CaptureSessionRejectUserError implements DisplayableError {
    code: CaptureSessionRejectUserErrorCode
    field: [String!]
    message: String!
}

enum CaptureSessionRejectUserErrorCode {
    CAPTURE_SESSION_NOT_FOUND
    CAPTURE_SESSION_INVALID_STATE
}

type CaptureSessionResolvePayload {
    captureSession: CaptureSession
    userErrors: [CaptureSessionResolveUserError!]!
}

type CaptureSessionResolveUserError implements DisplayableError {
    code: CaptureSessionResolveUserErrorCode
    field: [String!]
    message: String!
}

enum CaptureSessionResolveUserErrorCode {
    CAPTURE_SESSION_NOT_FOUND
    CAPTURE_SESSION_INVALID_STATE
}

type CaptureSessionStatus {
    code: CaptureSessionStatusCode!
    reason: CaptureSessionStatusReason
}

enum CaptureSessionStatusCode {
    REJECTED
    RESOLVED
}

type CaptureSessionStatusReason {
    code: CaptureSessionStatusReasonRejectionCode!
    merchantMessage: String
}

enum CaptureSessionStatusReasonRejectionCode {
    PROCESSING_ERROR
    AUTHORIZATION_EXPIRED
}

type Channel implements Node {
    app: App!
    collectionPublicationsV3(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationConnection!
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CollectionConnection!
    handle: String! @deprecated(reason: "Use `id` instead")
    hasCollection(id: ID!): Boolean!
    id: ID!
    name: String!
    navigationItems: [NavigationItem!]! @deprecated(reason: "Use App.navigationItems instead")
    overviewPath: URL @deprecated(reason: "Use App.launchUrl instead")
    productPublications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductPublicationConnection! @deprecated(reason: "Use `productPublicationsV3` instead")
    productPublicationsV3(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductConnection!
    supportsFuturePublishing: Boolean!
}

type ChannelConnection {
    edges: [ChannelEdge!]!
    pageInfo: PageInfo!
}

type ChannelEdge {
    cursor: String!
    node: Channel!
}

enum CodeDiscountSortKeys {
    STARTS_AT
    ENDS_AT
    TITLE
    CREATED_AT
    UPDATED_AT
    ID
    RELEVANCE
}

type Collection implements HasMetafields & Node & Publishable & HasPublishedTranslations {
    availablePublicationCount: Int!
    description(truncateAt: Int): String!
    descriptionHtml: HTML!
    feedback: ResourceFeedback
    handle: String!
    hasProduct(id: ID!): Boolean!
    id: ID!
    image(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    legacyResourceId: UnsignedInt64!
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductCollectionSortKeys = COLLECTION_DEFAULT, query: String): ProductConnection!
    productsCount: Int!
    publicationCount(onlyPublished: Boolean = true): Int!
    publications(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CollectionPublicationConnection! @deprecated(reason: "Use `resourcePublications` instead")
    publishedOnChannel(channelId: ID!): Boolean! @deprecated(reason: "Use `publishedOnPublication` instead")
    publishedOnCurrentChannel: Boolean! @deprecated(reason: "Use `publishedOnCurrentPublication` instead")
    publishedOnCurrentPublication: Boolean!
    publishedOnPublication(publicationId: ID!): Boolean!
    resourcePublications(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationConnection!
    resourcePublicationsV2(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationV2Connection!
    ruleSet: CollectionRuleSet
    seo: SEO!
    sortOrder: CollectionSortOrder!
    storefrontId: StorefrontID!
    templateSuffix: String
    title: String!
    translations(locale: String!): [PublishedTranslation!]!
    unpublishedChannels(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ChannelConnection! @deprecated(reason: "Use `unpublishedPublications` instead")
    unpublishedPublications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PublicationConnection!
    updatedAt: DateTime!
}

type CollectionAddProductsPayload {
    collection: Collection
    userErrors: [UserError!]!
}

type CollectionConnection {
    edges: [CollectionEdge!]!
    pageInfo: PageInfo!
}

type CollectionCreatePayload {
    collection: Collection
    userErrors: [UserError!]!
}

input CollectionDeleteInput {
    id: ID!
}

type CollectionDeletePayload {
    deletedCollectionId: ID
    shop: Shop!
    userErrors: [UserError!]!
}

type CollectionEdge {
    cursor: String!
    node: Collection!
}

input CollectionInput {
    descriptionHtml: String
    handle: String
    id: ID
    image: ImageInput
    products: [ID!]
    publications: [CollectionPublicationInput!]
    privateMetafields: [PrivateMetafieldInput!]
    ruleSet: CollectionRuleSetInput
    templateSuffix: String
    sortOrder: CollectionSortOrder
    title: String
    metafields: [MetafieldInput!]
    seo: SEOInput
    redirectNewHandle: Boolean = false
}

type CollectionPublication {
    channel: Channel! @deprecated(reason: "Use `publication` instead")
    collection: Collection!
    isPublished: Boolean!
    publication: Publication!
    publishDate: DateTime!
}

type CollectionPublicationConnection {
    edges: [CollectionPublicationEdge!]!
    pageInfo: PageInfo!
}

type CollectionPublicationEdge {
    cursor: String!
    node: CollectionPublication!
}

input CollectionPublicationInput {
    publicationId: ID
    channelId: ID
    channelHandle: String
}

input CollectionPublishInput {
    id: ID!
    collectionPublications: [CollectionPublicationInput!]!
}

type CollectionPublishPayload {
    collection: Collection
    collectionPublications: [CollectionPublication!]
    shop: Shop!
    userErrors: [UserError!]!
}

type CollectionRemoveProductsPayload {
    job: Job
    userErrors: [UserError!]!
}

type CollectionReorderProductsPayload {
    job: Job
    userErrors: [UserError!]!
}

type CollectionRule {
    column: CollectionRuleColumn!
    condition: String!
    relation: CollectionRuleRelation!
}

enum CollectionRuleColumn {
    TAG
    TITLE
    TYPE
    VENDOR
    VARIANT_PRICE
    IS_PRICE_REDUCED
    VARIANT_COMPARE_AT_PRICE
    VARIANT_WEIGHT
    VARIANT_INVENTORY
    VARIANT_TITLE
}

type CollectionRuleConditions {
    allowedRelations: [CollectionRuleRelation!]!
    defaultRelation: CollectionRuleRelation!
    ruleType: CollectionRuleColumn!
}

input CollectionRuleInput {
    column: CollectionRuleColumn!
    relation: CollectionRuleRelation!
    condition: String!
}

enum CollectionRuleRelation {
    CONTAINS
    ENDS_WITH
    EQUALS
    GREATER_THAN
    IS_NOT_SET
    IS_SET
    LESS_THAN
    NOT_CONTAINS
    NOT_EQUALS
    STARTS_WITH
}

type CollectionRuleSet {
    appliedDisjunctively: Boolean!
    rules: [CollectionRule!]!
}

input CollectionRuleSetInput {
    appliedDisjunctively: Boolean!
    rules: [CollectionRuleInput!]
}

enum CollectionSortKeys {
    TITLE
    UPDATED_AT
    ID
    RELEVANCE
}

enum CollectionSortOrder {
    ALPHA_ASC
    ALPHA_DESC
    BEST_SELLING
    CREATED
    CREATED_DESC
    MANUAL
    PRICE_ASC
    PRICE_DESC
}

input CollectionUnpublishInput {
    id: ID!
    collectionPublications: [CollectionPublicationInput!]!
}

type CollectionUnpublishPayload {
    collection: Collection
    shop: Shop!
    userErrors: [UserError!]!
}

type CollectionUpdatePayload {
    collection: Collection
    job: Job
    userErrors: [UserError!]!
}

type CommentEvent implements Node & Event {
    appTitle: String
    attachments: [CommentEventAttachment!]!
    attributeToApp: Boolean!
    attributeToUser: Boolean!
    canDelete: Boolean!
    canEdit: Boolean!
    createdAt: DateTime!
    criticalAlert: Boolean!
    edited: Boolean!
    embed: CommentEventEmbed
    id: ID!
    message: FormattedString!
    rawMessage: String!
    subject: CommentEventSubject!
}

type CommentEventAttachment {
    fileExtension: String
    id: ID!
    image(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    name: String!
    size: Int!
    url: URL!
}

union CommentEventEmbed = Customer | DraftOrder | Order | Product | ProductVariant

interface CommentEventSubject {
    hasTimelineComment: Boolean!
    id: ID!
}

type CountriesInShippingZones {
    countryCodes: [CountryCode!]!
    includeRestOfWorld: Boolean!
}

enum CountryCode {
    AF
    AX
    AL
    DZ
    AD
    AO
    AI
    AG
    AR
    AM
    AW
    AC
    AU
    AT
    AZ
    BS
    BH
    BD
    BB
    BY
    BE
    BZ
    BJ
    BM
    BT
    BO
    BA
    BW
    BV
    BR
    IO
    BN
    BG
    BF
    BI
    KH
    CA
    CV
    BQ
    KY
    CF
    TD
    CL
    CN
    CX
    CC
    CO
    KM
    CG
    CD
    CK
    CR
    HR
    CU
    CW
    CY
    CZ
    CI
    DK
    DJ
    DM
    DO
    EC
    EG
    SV
    GQ
    ER
    EE
    SZ
    ET
    FK
    FO
    FJ
    FI
    FR
    GF
    PF
    TF
    GA
    GM
    GE
    DE
    GH
    GI
    GR
    GL
    GD
    GP
    GT
    GG
    GN
    GW
    GY
    HT
    HM
    VA
    HN
    HK
    HU
    IS
    IN
    ID
    IR
    IQ
    IE
    IM
    IL
    IT
    JM
    JP
    JE
    JO
    KZ
    KE
    KI
    KP
    XK
    KW
    KG
    LA
    LV
    LB
    LS
    LR
    LY
    LI
    LT
    LU
    MO
    MG
    MW
    MY
    MV
    ML
    MT
    MQ
    MR
    MU
    YT
    MX
    MD
    MC
    MN
    ME
    MS
    MA
    MZ
    MM
    NA
    NR
    NP
    NL
    AN
    NC
    NZ
    NI
    NE
    NG
    NU
    NF
    MK
    NO
    OM
    PK
    PS
    PA
    PG
    PY
    PE
    PH
    PN
    PL
    PT
    QA
    CM
    RE
    RO
    RU
    RW
    BL
    SH
    KN
    LC
    MF
    PM
    WS
    SM
    ST
    SA
    SN
    RS
    SC
    SL
    SG
    SX
    SK
    SI
    SB
    SO
    ZA
    GS
    KR
    SS
    ES
    LK
    VC
    SD
    SR
    SJ
    SE
    CH
    SY
    TW
    TJ
    TZ
    TH
    TL
    TG
    TK
    TO
    TT
    TA
    TN
    TR
    TM
    TC
    TV
    UG
    UA
    AE
    GB
    US
    UM
    UY
    UZ
    VU
    VE
    VN
    VG
    WF
    EH
    YE
    ZM
    ZW
    ZZ
}

type CountryHarmonizedSystemCode {
    countryCode: CountryCode!
    harmonizedSystemCode: String!
}

type CountryHarmonizedSystemCodeConnection {
    edges: [CountryHarmonizedSystemCodeEdge!]!
    pageInfo: PageInfo!
}

type CountryHarmonizedSystemCodeEdge {
    cursor: String!
    node: CountryHarmonizedSystemCode!
}

input CountryHarmonizedSystemCodeInput {
    harmonizedSystemCode: String!
    countryCode: CountryCode!
}

input CreateMediaInput {
    originalSource: String!
    alt: String
    mediaContentType: MediaContentType!
}

enum CropRegion {
    CENTER
    TOP
    BOTTOM
    LEFT
    RIGHT
}

enum CurrencyCode {
    USD
    EUR
    GBP
    CAD
    AFN
    ALL
    DZD
    AOA
    ARS
    AMD
    AWG
    AUD
    BBD
    AZN
    BDT
    BSD
    BHD
    BIF
    BZD
    BMD
    BTN
    BAM
    BRL
    BOB
    BWP
    BND
    BGN
    MMK
    KHR
    CVE
    KYD
    XAF
    CLP
    CNY
    COP
    KMF
    CDF
    CRC
    HRK
    CZK
    DKK
    DOP
    XCD
    EGP
    ETB
    XPF
    FJD
    GMD
    GHS
    GTQ
    GYD
    GEL
    HTG
    HNL
    HKD
    HUF
    ISK
    INR
    IDR
    ILS
    IQD
    JMD
    JPY
    JEP
    JOD
    KZT
    KES
    KWD
    KGS
    LAK
    LVL
    LBP
    LSL
    LRD
    LTL
    MGA
    MKD
    MOP
    MWK
    MVR
    MXN
    MYR
    MUR
    MDL
    MAD
    MNT
    MZN
    NAD
    NPR
    ANG
    NZD
    NIO
    NGN
    NOK
    OMR
    PAB
    PKR
    PGK
    PYG
    PEN
    PHP
    PLN
    QAR
    RON
    RUB
    RWF
    WST
    SAR
    STD
    RSD
    SCR
    SGD
    SDG
    SYP
    ZAR
    KRW
    SSP
    SBD
    LKR
    SRD
    SZL
    SEK
    CHF
    TWD
    THB
    TZS
    TTD
    TND
    TRY
    TMT
    UGX
    UAH
    AED
    UYU
    UZS
    VUV
    VND
    XOF
    YER
    ZMW
    BYN
    BYR @deprecated(reason: "`BYR` is deprecated. Use `BYN` available from version `2021-01` onwards instead.")
    DJF
    ERN
    FKP
    GIP
    GNF
    IRR
    KID
    LYD
    MRU
    SLL
    SHP
    SOS
    TJS
    TOP
    VEF @deprecated(reason: "`VEF` is deprecated. Use `VES` available from version `2020-10` onwards instead.")
    VES
    XXX
}

type CurrencyFormats {
    moneyFormat: FormattedString!
    moneyInEmailsFormat: String!
    moneyWithCurrencyFormat: FormattedString!
    moneyWithCurrencyInEmailsFormat: String!
}

type CurrencySetting {
    currencyCode: CurrencyCode!
    currencyName: String!
    enabled: Boolean!
    rateUpdatedAt: DateTime
}

type CurrencySettingConnection {
    edges: [CurrencySettingEdge!]!
    pageInfo: PageInfo!
}

type CurrencySettingEdge {
    cursor: String!
    node: CurrencySetting!
}

type Customer implements Node & CommentEventSubject & HasMetafields & LegacyInteroperability & HasEvents {
    acceptsMarketing: Boolean!
    acceptsMarketingUpdatedAt: DateTime!
    addresses(first: Int): [MailingAddress!]!
    averageOrderAmount: Money @deprecated(reason: "Use `averageOrderAmountV2` instead")
    averageOrderAmountV2: MoneyV2
    canDelete: Boolean!
    createdAt: DateTime!
    defaultAddress: MailingAddress
    displayName: String!
    email: String
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
    firstName: String
    hasNote: Boolean!
    hasTimelineComment: Boolean!
    id: ID!
    image(size: Int): Image!
    lastName: String
    lastOrder: Order
    legacyResourceId: UnsignedInt64!
    lifetimeDuration: String!
    locale: String!
    marketingOptInLevel: CustomerMarketingOptInLevel
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    multipassIdentifier: String
    note: String
    orders(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: OrderSortKeys = ID, query: String): OrderConnection!
    ordersCount: UnsignedInt64!
    paymentMethods(showRevoked: Boolean = false, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CustomerPaymentMethodConnection!
    phone: String
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    productSubscriberStatus: CustomerProductSubscriberStatus!
    state: CustomerState!
    subscriptionContracts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionContractConnection!
    tags: [String!]!
    taxExempt: Boolean!
    taxExemptions: [TaxExemption!]!
    totalSpent: Money!
    totalSpentV2: MoneyV2!
    updatedAt: DateTime!
    validEmailAddress: Boolean!
    verifiedEmail: Boolean!
}

type CustomerAddTaxExemptionsPayload {
    customer: Customer
    userErrors: [UserError!]!
}

type CustomerConnection {
    edges: [CustomerEdge!]!
    pageInfo: PageInfo!
}

type CustomerCreatePayload {
    customer: Customer
    userErrors: [UserError!]!
}

type CustomerCreditCard {
    billingAddress: CustomerCreditCardBillingAddress
    brand: String!
    expiresSoon: Boolean!
    expiryMonth: Int!
    expiryYear: Int!
    firstDigits: String
    isRevocable: Boolean!
    lastDigits: String!
    maskedNumber: String!
    name: String!
}

type CustomerCreditCardBillingAddress {
    address1: String
    city: String
    country: String
    countryCode: CountryCode
    province: String
    provinceCode: String
    zip: String
}

input CustomerDeleteInput {
    id: ID!
}

type CustomerDeletePayload {
    deletedCustomerId: ID
    shop: Shop!
    userErrors: [UserError!]!
}

type CustomerEdge {
    cursor: String!
    node: Customer!
}

type CustomerGenerateAccountActivationUrlPayload {
    accountActivationUrl: URL
    userErrors: [UserError!]!
}

input CustomerInput {
    acceptsMarketing: Boolean
    acceptsMarketingUpdatedAt: DateTime
    addresses: [MailingAddressInput!]
    email: String
    firstName: String
    id: ID
    lastName: String
    locale: String
    marketingOptInLevel: CustomerMarketingOptInLevel
    metafields: [MetafieldInput!]
    note: String
    phone: String
    privateMetafields: [PrivateMetafieldInput!]
    tags: [String!]
    taxExempt: Boolean
    taxExemptions: [TaxExemption!]
}

type CustomerJourney {
    customerOrderIndex: Int!
    daysToConversion: Int!
    firstVisit: CustomerVisit!
    lastVisit: CustomerVisit
    moments: [CustomerMoment!]!
}

type CustomerJourneySummary {
    customerOrderIndex: Int
    daysToConversion: Int
    firstVisit: CustomerVisit
    lastVisit: CustomerVisit
    moments(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CustomerMomentConnection
    momentsCount: Int
    ready: Boolean!
}

enum CustomerMarketingOptInLevel {
    SINGLE_OPT_IN
    CONFIRMED_OPT_IN
    UNKNOWN
}

interface CustomerMoment {
    occurredAt: DateTime!
}

type CustomerMomentConnection {
    edges: [CustomerMomentEdge!]!
    pageInfo: PageInfo!
}

type CustomerMomentEdge {
    cursor: String!
    node: CustomerMoment!
}

union CustomerPaymentInstrument = CustomerCreditCard | CustomerPaypalBillingAgreement

type CustomerPaymentInstrumentBillingAddress {
    address1: String
    city: String
    country: String
    countryCode: CountryCode
    name: String
    province: String
    provinceCode: String
    zip: String
}

type CustomerPaymentMethod implements Node {
    customer: Customer
    id: ID!
    instrument: CustomerPaymentInstrument
    revokedAt: DateTime
    subscriptionContracts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionContractConnection!
}

type CustomerPaymentMethodConnection {
    edges: [CustomerPaymentMethodEdge!]!
    pageInfo: PageInfo!
}

type CustomerPaymentMethodCreditCardCreatePayload {
    customerPaymentMethod: CustomerPaymentMethod
    userErrors: [UserError!]!
}

type CustomerPaymentMethodCreditCardUpdatePayload {
    customerPaymentMethod: CustomerPaymentMethod
    userErrors: [UserError!]!
}

type CustomerPaymentMethodEdge {
    cursor: String!
    node: CustomerPaymentMethod!
}

type CustomerPaymentMethodPaypalBillingAgreementCreatePayload {
    customerPaymentMethod: CustomerPaymentMethod
    userErrors: [CustomerPaymentMethodUserError!]!
}

type CustomerPaymentMethodPaypalBillingAgreementUpdatePayload {
    customerPaymentMethod: CustomerPaymentMethod
    userErrors: [CustomerPaymentMethodUserError!]!
}

type CustomerPaymentMethodRemoteCreatePayload {
    customerPaymentMethod: CustomerPaymentMethod
    userErrors: [CustomerPaymentMethodRemoteUserError!]!
}

type CustomerPaymentMethodRemoteCreditCardCreatePayload {
    customerPaymentMethod: CustomerPaymentMethod
    userErrors: [CustomerPaymentMethodUserError!]!
}

input CustomerPaymentMethodRemoteInput {
    stripePaymentMethod: RemoteStripePaymentMethodInput
    authorizeNetCustomerPaymentProfile: RemoteAuthorizeNetCustomerPaymentProfileInput
}

type CustomerPaymentMethodRemoteUserError implements DisplayableError {
    code: CustomerPaymentMethodRemoteUserErrorCode
    field: [String!]
    message: String!
}

enum CustomerPaymentMethodRemoteUserErrorCode {
    INVALID
    PRESENT
    TAKEN
    EXACTLY_ONE_REMOTE_REFERENCE_REQUIRED
    AUTHORIZE_NET_NOT_ENABLED_FOR_SUBSCRIPTIONS
}

type CustomerPaymentMethodRevokePayload {
    revokedCustomerPaymentMethodId: ID
    userErrors: [UserError!]!
}

type CustomerPaymentMethodSendUpdateEmailPayload {
    customer: Customer
    userErrors: [UserError!]!
}

type CustomerPaymentMethodUserError implements DisplayableError {
    code: CustomerPaymentMethodUserErrorCode
    field: [String!]
    message: String!
}

enum CustomerPaymentMethodUserErrorCode {
    INVALID
    PRESENT
    TAKEN
}

type CustomerPaypalBillingAgreement {
    billingAddress: CustomerPaymentInstrumentBillingAddress
    inactive: Boolean!
    isRevocable: Boolean!
    paypalAccountEmail: String
}

enum CustomerProductSubscriberStatus {
    ACTIVE
    CANCELLED
    EXPIRED
    FAILED
    NEVER_SUBSCRIBED
    PAUSED
}

type CustomerRemoveTaxExemptionsPayload {
    customer: Customer
    userErrors: [UserError!]!
}

type CustomerReplaceTaxExemptionsPayload {
    customer: Customer
    userErrors: [UserError!]!
}

enum CustomerSavedSearchSortKeys {
    NAME
    ID
    RELEVANCE
}

enum CustomerSortKeys {
    NAME
    LOCATION
    ORDERS_COUNT
    LAST_ORDER_DATE
    TOTAL_SPENT
    UPDATED_AT
    ID
    RELEVANCE
}

enum CustomerState {
    DECLINED
    DISABLED
    ENABLED
    INVITED
}

type CustomerUpdateDefaultAddressPayload {
    customer: Customer
    userErrors: [UserError!]!
}

type CustomerUpdatePayload {
    customer: Customer
    userErrors: [UserError!]!
}

type CustomerVisit implements CustomerMoment & Node {
    id: ID!
    landingPage: URL
    landingPageHtml: HTML
    marketingEvent: MarketingEvent
    occurredAt: DateTime!
    referralCode: String
    referralInfoHtml: FormattedString!
    referrerUrl: URL
    source: String!
    sourceDescription: String
    sourceType: MarketingTactic
    utmParameters: UTMParameters
}

scalar Date

scalar DateTime

enum DayOfTheWeek {
    MONDAY
    TUESDAY
    WEDNESDAY
    THURSDAY
    FRIDAY
    SATURDAY
    SUNDAY
}

scalar Decimal

type DeletionEvent {
    occurredAt: DateTime!
    subjectId: ID!
    subjectType: DeletionEventSubjectType!
}

type DeletionEventConnection {
    edges: [DeletionEventEdge!]!
    pageInfo: PageInfo!
}

type DeletionEventEdge {
    cursor: String!
    node: DeletionEvent!
}

enum DeletionEventSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

enum DeletionEventSubjectType {
    COLLECTION
    PRODUCT
}

type DeliveryAvailableService {
    countries: DeliveryCountryCodesOrRestOfWorld!
    name: String!
}

type DeliveryCarrierService implements Node {
    availableServicesForCountries(origins: [ID!], countryCodes: [CountryCode!], restOfWorld: Boolean!): [DeliveryAvailableService!]!
    formattedName: String
    icon: Image!
    id: ID!
    name: String
}

type DeliveryCarrierServiceAndLocations {
    carrierService: DeliveryCarrierService!
    locations: [Location!]!
}

type DeliveryCondition implements Node {
    conditionCriteria: DeliveryConditionCriteria!
    field: DeliveryConditionField!
    id: ID!
    operator: DeliveryConditionOperator!
}

union DeliveryConditionCriteria = MoneyV2 | Weight

enum DeliveryConditionField {
    TOTAL_WEIGHT
    TOTAL_PRICE
}

enum DeliveryConditionOperator {
    GREATER_THAN_OR_EQUAL_TO
    LESS_THAN_OR_EQUAL_TO
}

type DeliveryCountry implements Node {
    code: DeliveryCountryCodeOrRestOfWorld!
    id: ID!
    name: String!
    provinces: [DeliveryProvince!]!
    translatedName: String!
}

type DeliveryCountryAndZone {
    country: DeliveryCountry!
    zone: String!
}

type DeliveryCountryCodeOrRestOfWorld {
    countryCode: CountryCode
    restOfWorld: Boolean!
}

type DeliveryCountryCodesOrRestOfWorld {
    countryCodes: [CountryCode!]!
    restOfWorld: Boolean!
}

input DeliveryCountryInput {
    code: CountryCode
    restOfWorld: Boolean
    provinces: [DeliveryProvinceInput!]
    includeAllProvinces: Boolean
}

type DeliveryLegacyModeBlocked {
    blocked: Boolean!
    reasons: [DeliveryLegacyModeBlockedReason!]
}

enum DeliveryLegacyModeBlockedReason {
    MULTI_LOCATION_DISABLED
    NO_LOCATIONS_FULFILLING_ONLINE_ORDERS
}

type DeliveryLocationGroup implements Node {
    id: ID!
    locations(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: LocationSortKeys = NAME, query: String, includeLegacy: Boolean = false, includeInactive: Boolean = false): LocationConnection!
}

type DeliveryLocationGroupZone {
    methodDefinitionCounts: DeliveryMethodDefinitionCounts!
    methodDefinitions(eligible: Boolean, type: DeliveryMethodDefinitionType, first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: MethodDefinitionSortKeys = ID): DeliveryMethodDefinitionConnection!
    zone: DeliveryZone!
}

type DeliveryLocationGroupZoneConnection {
    edges: [DeliveryLocationGroupZoneEdge!]!
    pageInfo: PageInfo!
}

type DeliveryLocationGroupZoneEdge {
    cursor: String!
    node: DeliveryLocationGroupZone!
}

input DeliveryLocationGroupZoneInput {
    id: ID
    name: String
    countries: [DeliveryCountryInput!]
    methodDefinitionsToCreate: [DeliveryMethodDefinitionInput!]
    methodDefinitionsToUpdate: [DeliveryMethodDefinitionInput!]
}

type DeliveryMethod implements Node {
    id: ID!
    methodType: DeliveryMethodType!
}

type DeliveryMethodDefinition implements Node {
    active: Boolean!
    description: String
    id: ID!
    methodConditions: [DeliveryCondition!]!
    name: String!
    rateProvider: DeliveryRateProvider!
}

type DeliveryMethodDefinitionConnection {
    edges: [DeliveryMethodDefinitionEdge!]!
    pageInfo: PageInfo!
}

type DeliveryMethodDefinitionCounts {
    participantDefinitionsCount: Int!
    rateDefinitionsCount: Int!
}

type DeliveryMethodDefinitionEdge {
    cursor: String!
    node: DeliveryMethodDefinition!
}

input DeliveryMethodDefinitionInput {
    id: ID
    name: String
    description: String
    active: Boolean
    rateDefinition: DeliveryRateDefinitionInput
    participant: DeliveryParticipantInput
    weightConditionsToCreate: [DeliveryWeightConditionInput!]
    priceConditionsToCreate: [DeliveryPriceConditionInput!]
    conditionsToUpdate: [DeliveryUpdateConditionInput!]
}

enum DeliveryMethodDefinitionType {
    MERCHANT
    PARTICIPANT
}

enum DeliveryMethodType {
    SHIPPING
    PICK_UP
    NONE
    RETAIL
    LOCAL
}

type DeliveryParticipant implements Node {
    adaptToNewServicesFlag: Boolean!
    carrierService: DeliveryCarrierService!
    fixedFee: MoneyV2
    id: ID!
    participantServices: [DeliveryParticipantService!]!
    percentageOfRateFee: Float!
}

input DeliveryParticipantInput {
    id: ID
    carrierServiceId: ID
    fixedFee: MoneyInput
    percentageOfRateFee: Float
    participantServices: [DeliveryParticipantServiceInput!]
    adaptToNewServices: Boolean
}

type DeliveryParticipantService {
    active: Boolean!
    name: String!
}

input DeliveryParticipantServiceInput {
    name: String!
    active: Boolean!
}

input DeliveryPriceConditionInput {
    criteria: MoneyInput
    operator: DeliveryConditionOperator
}

type DeliveryProductVariantsCount {
    capped: Boolean!
    count: Int!
}

type DeliveryProfile implements Node {
    activeMethodDefinitionsCount: Int!
    default: Boolean!
    id: ID!
    legacyMode: Boolean!
    locationsWithoutRatesCount: Int!
    name: String!
    originLocationCount: Int!
    productVariantsCount: Int! @deprecated(reason: "Use `productVariantsCountV2` instead")
    productVariantsCountV2: DeliveryProductVariantsCount!
    profileItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProfileItemSortKeys = ID): DeliveryProfileItemConnection!
    profileLocationGroups: [DeliveryProfileLocationGroup!]!
    sellingPlanGroups(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SellingPlanGroupConnection!
    unassignedLocations: [Location!]!
    zoneCountryCount: Int!
}

type DeliveryProfileConnection {
    edges: [DeliveryProfileEdge!]!
    pageInfo: PageInfo!
}

type deliveryProfileCreatePayload {
    profile: DeliveryProfile
    userErrors: [UserError!]!
}

type DeliveryProfileEdge {
    cursor: String!
    node: DeliveryProfile!
}

input DeliveryProfileInput {
    name: String
    profileLocationGroups: [DeliveryProfileLocationGroupInput!]
    locationGroupsToCreate: [DeliveryProfileLocationGroupInput!]
    locationGroupsToUpdate: [DeliveryProfileLocationGroupInput!]
    locationGroupsToDelete: [ID!]
    variantsToAssociate: [ID!]
    variantsToDissociate: [ID!]
    zonesToDelete: [ID!]
    methodDefinitionsToDelete: [ID!]
    conditionsToDelete: [ID!]
    sellingPlanGroupsToAssociate: [ID!]
    sellingPlanGroupsToDissociate: [ID!]
}

type DeliveryProfileItem {
    product: Product!
    variants(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductVariantSortKeys = ID): ProductVariantConnection!
}

type DeliveryProfileItemConnection {
    edges: [DeliveryProfileItemEdge!]!
    pageInfo: PageInfo!
}

type DeliveryProfileItemEdge {
    cursor: String!
    node: DeliveryProfileItem!
}

type DeliveryProfileLocationGroup {
    countriesInAnyZone: [DeliveryCountryAndZone!]!
    locationGroup: DeliveryLocationGroup!
    locationGroupZones(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): DeliveryLocationGroupZoneConnection!
}

input DeliveryProfileLocationGroupInput {
    id: ID
    locations: [ID!]
    zonesToCreate: [DeliveryLocationGroupZoneInput!]
    zonesToUpdate: [DeliveryLocationGroupZoneInput!]
}

type deliveryProfileRemovePayload {
    job: Job
    userErrors: [UserError!]!
}

type deliveryProfileUpdatePayload {
    profile: DeliveryProfile
    userErrors: [UserError!]!
}

type DeliveryProvince implements Node {
    code: String!
    id: ID!
    name: String!
    translatedName: String!
}

input DeliveryProvinceInput {
    code: String!
}

type DeliveryRateDefinition implements Node {
    id: ID!
    price: MoneyV2!
}

input DeliveryRateDefinitionInput {
    id: ID
    price: MoneyInput!
}

union DeliveryRateProvider = DeliveryParticipant | DeliveryRateDefinition

type DeliverySetting {
    legacyModeBlocked: DeliveryLegacyModeBlocked!
    legacyModeProfiles: Boolean!
}

input DeliverySettingInput {
    legacyModeProfiles: Boolean
}

type DeliverySettingUpdatePayload {
    setting: DeliverySetting
    userErrors: [UserError!]!
}

type DeliveryShippingOriginAssignPayload {
    userErrors: [UserError!]!
}

input DeliveryUpdateConditionInput {
    id: ID!
    criteria: Float
    criteriaUnit: String
    field: DeliveryConditionField
    operator: DeliveryConditionOperator
}

input DeliveryWeightConditionInput {
    criteria: WeightInput
    operator: DeliveryConditionOperator
}

type DeliveryZone implements Node {
    countries: [DeliveryCountry!]!
    id: ID!
    name: String!
}

enum DigitalWallet {
    APPLE_PAY
    ANDROID_PAY
    GOOGLE_PAY
    SHOPIFY_PAY
}

type DiscountAllocation {
    allocatedAmount: MoneyV2! @deprecated(reason: "Use `allocatedAmountSet` instead")
    allocatedAmountSet: MoneyBag!
    discountApplication: DiscountApplication!
}

type DiscountAmount {
    amount: MoneyV2!
    appliesOnEachItem: Boolean!
}

input DiscountAmountInput {
    amount: Decimal
    appliesOnEachItem: Boolean
}

interface DiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    index: Int!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    value: PricingValue!
}

enum DiscountApplicationAllocationMethod {
    ACROSS
    EACH
    ONE @deprecated(reason: "Use ACROSS instead.")
}

type DiscountApplicationConnection {
    edges: [DiscountApplicationEdge!]!
    pageInfo: PageInfo!
}

type DiscountApplicationEdge {
    cursor: String!
    node: DiscountApplication!
}

enum DiscountApplicationLevel {
    ORDER
    LINE
}

enum DiscountApplicationTargetSelection {
    ALL
    ENTITLED
    EXPLICIT
}

enum DiscountApplicationTargetType {
    LINE_ITEM
    SHIPPING_LINE
}

union DiscountAutomatic = DiscountAutomaticBasic | DiscountAutomaticBxgy

type DiscountAutomaticActivatePayload {
    automaticDiscountNode: DiscountAutomaticNode
    userErrors: [DiscountUserError!]!
}

type DiscountAutomaticBasic {
    asyncUsageCount: Int!
    createdAt: DateTime!
    customerGets: DiscountCustomerGets!
    endsAt: DateTime
    minimumRequirement: DiscountMinimumRequirement!
    shortSummary: String!
    startsAt: DateTime!
    status: DiscountStatus!
    summary: String!
    title: String!
    usageCount: Int! @deprecated(reason: "Use `asyncUsageCount` instead")
}

type DiscountAutomaticBasicCreatePayload {
    automaticDiscountNode: DiscountAutomaticNode
    userErrors: [DiscountUserError!]!
}

input DiscountAutomaticBasicInput {
    title: String
    startsAt: DateTime
    endsAt: DateTime
    minimumRequirement: DiscountMinimumRequirementInput
    customerGets: DiscountCustomerGetsInput
}

type DiscountAutomaticBasicUpdatePayload {
    automaticDiscountNode: DiscountAutomaticNode
    userErrors: [DiscountUserError!]!
}

type DiscountAutomaticBulkDeletePayload {
    job: Job
    userErrors: [DiscountUserError!]!
}

type DiscountAutomaticBxgy implements Node & HasEvents {
    asyncUsageCount: Int!
    createdAt: DateTime!
    customerBuys: DiscountCustomerBuys!
    customerGets: DiscountCustomerGets!
    endsAt: DateTime
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
    id: ID! @deprecated(reason: "Use DiscountAutomaticNode.id instead.")
    startsAt: DateTime!
    status: DiscountStatus!
    summary: String!
    title: String!
    usageCount: Int! @deprecated(reason: "Use `asyncUsageCount` instead")
    usesPerOrderLimit: Int
}

type DiscountAutomaticBxgyCreatePayload {
    automaticDiscountNode: DiscountAutomaticNode
    userErrors: [DiscountUserError!]!
}

input DiscountAutomaticBxgyInput {
    startsAt: DateTime
    endsAt: DateTime
    title: String
    usesPerOrderLimit: UnsignedInt64
    customerBuys: DiscountCustomerBuysInput
    customerGets: DiscountCustomerGetsInput
}

type DiscountAutomaticBxgyUpdatePayload {
    automaticDiscountNode: DiscountAutomaticNode
    userErrors: [DiscountUserError!]!
}

type DiscountAutomaticConnection {
    edges: [DiscountAutomaticEdge!]!
    pageInfo: PageInfo!
}

type DiscountAutomaticDeactivatePayload {
    automaticDiscountNode: DiscountAutomaticNode
    userErrors: [DiscountUserError!]!
}

type DiscountAutomaticDeletePayload {
    deletedAutomaticDiscountId: ID
    userErrors: [DiscountUserError!]!
}

type DiscountAutomaticEdge {
    cursor: String!
    node: DiscountAutomatic!
}

type DiscountAutomaticNode implements Node & HasEvents {
    automaticDiscount: DiscountAutomatic!
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
    id: ID!
}

type DiscountAutomaticNodeConnection {
    edges: [DiscountAutomaticNodeEdge!]!
    pageInfo: PageInfo!
}

type DiscountAutomaticNodeEdge {
    cursor: String!
    node: DiscountAutomaticNode!
}

union DiscountCode = DiscountCodeBasic | DiscountCodeBxgy | DiscountCodeFreeShipping

type DiscountCodeActivatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

type DiscountCodeApplication implements DiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    code: String!
    index: Int!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    value: PricingValue!
}

type DiscountCodeBasic {
    appliesOncePerCustomer: Boolean!
    asyncUsageCount: Int!
    codeCount: Int!
    codes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DiscountCodeSortKeys = ID, query: String, savedSearchId: ID): DiscountRedeemCodeConnection!
    createdAt: DateTime!
    customerGets: DiscountCustomerGets!
    customerSelection: DiscountCustomerSelection!
    endsAt: DateTime
    hasTimelineComment: Boolean!
    minimumRequirement: DiscountMinimumRequirement
    recurringCycleLimit: Int
    shareableUrls: [DiscountShareableUrl!]!
    shortSummary: String!
    startsAt: DateTime!
    status: DiscountStatus!
    summary: String!
    title: String!
    totalSales: MoneyV2
    usageLimit: Int
}

type DiscountCodeBasicCreatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

input DiscountCodeBasicInput {
    title: String
    startsAt: DateTime
    endsAt: DateTime
    usageLimit: Int
    appliesOncePerCustomer: Boolean
    minimumRequirement: DiscountMinimumRequirementInput
    customerGets: DiscountCustomerGetsInput
    customerSelection: DiscountCustomerSelectionInput
    code: String
    recurringCycleLimit: Int
}

type DiscountCodeBasicUpdatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

type DiscountCodeBulkActivatePayload {
    job: Job
    userErrors: [DiscountUserError!]!
}

type DiscountCodeBulkDeactivatePayload {
    job: Job
    userErrors: [DiscountUserError!]!
}

type DiscountCodeBulkDeletePayload {
    job: Job
    userErrors: [DiscountUserError!]!
}

type DiscountCodeBxgy {
    appliesOncePerCustomer: Boolean!
    asyncUsageCount: Int!
    codeCount: Int!
    codes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DiscountCodeSortKeys = ID, query: String, savedSearchId: ID): DiscountRedeemCodeConnection!
    createdAt: DateTime!
    customerBuys: DiscountCustomerBuys!
    customerGets: DiscountCustomerGets!
    customerSelection: DiscountCustomerSelection!
    endsAt: DateTime
    hasTimelineComment: Boolean!
    shareableUrls: [DiscountShareableUrl!]!
    startsAt: DateTime!
    status: DiscountStatus!
    summary: String!
    title: String!
    totalSales: MoneyV2
    usageLimit: Int
    usesPerOrderLimit: Int
}

type DiscountCodeBxgyCreatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

input DiscountCodeBxgyInput {
    title: String
    startsAt: DateTime
    endsAt: DateTime
    customerBuys: DiscountCustomerBuysInput
    customerGets: DiscountCustomerGetsInput
    customerSelection: DiscountCustomerSelectionInput
    code: String
    usageLimit: Int
    usesPerOrderLimit: Int
    appliesOncePerCustomer: Boolean
}

type DiscountCodeBxgyUpdatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

type DiscountCodeDeactivatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

type DiscountCodeDeletePayload {
    deletedCodeDiscountId: ID
    userErrors: [DiscountUserError!]!
}

type DiscountCodeFreeShipping {
    appliesOnOneTimePurchase: Boolean!
    appliesOnSubscription: Boolean!
    appliesOncePerCustomer: Boolean!
    asyncUsageCount: Int!
    codeCount: Int!
    codes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DiscountCodeSortKeys = ID, query: String, savedSearchId: ID): DiscountRedeemCodeConnection!
    createdAt: DateTime!
    customerSelection: DiscountCustomerSelection!
    destinationSelection: DiscountShippingDestinationSelection!
    endsAt: DateTime
    hasTimelineComment: Boolean!
    maximumShippingPrice: MoneyV2
    minimumRequirement: DiscountMinimumRequirement
    recurringCycleLimit: Int
    shareableUrls: [DiscountShareableUrl!]!
    shortSummary: String!
    startsAt: DateTime!
    status: DiscountStatus!
    summary: String!
    title: String!
    totalSales: MoneyV2
    usageLimit: Int
}

type DiscountCodeFreeShippingCreatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

input DiscountCodeFreeShippingInput {
    title: String
    startsAt: DateTime
    endsAt: DateTime
    code: String
    usageLimit: Int
    appliesOncePerCustomer: Boolean
    minimumRequirement: DiscountMinimumRequirementInput
    customerSelection: DiscountCustomerSelectionInput
    destination: DiscountShippingDestinationSelectionInput
    maximumShippingPrice: Decimal
    recurringCycleLimit: Int
    appliesOnOneTimePurchase: Boolean
    appliesOnSubscription: Boolean
}

type DiscountCodeFreeShippingUpdatePayload {
    codeDiscountNode: DiscountCodeNode
    userErrors: [DiscountUserError!]!
}

type DiscountCodeNode implements Node & HasEvents {
    codeDiscount: DiscountCode!
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
    id: ID!
}

type DiscountCodeNodeConnection {
    edges: [DiscountCodeNodeEdge!]!
    pageInfo: PageInfo!
}

type DiscountCodeNodeEdge {
    cursor: String!
    node: DiscountCodeNode!
}

type DiscountCodeRedeemCodeBulkDeletePayload {
    job: Job
    userErrors: [DiscountUserError!]!
}

enum DiscountCodeSortKeys {
    CODE
    CREATED_AT
    ID
    RELEVANCE
}

type DiscountCollections {
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CollectionConnection!
}

input DiscountCollectionsInput {
    add: [ID!]
    remove: [ID!]
}

type DiscountCountries {
    countries: [CountryCode!]!
    includeRestOfWorld: Boolean!
}

input DiscountCountriesInput {
    add: [CountryCode!]
    remove: [CountryCode!]
    includeRestOfWorld: Boolean = false
}

type DiscountCountryAll {
    allCountries: Boolean!
}

type DiscountCustomerAll {
    allCustomers: Boolean!
}

type DiscountCustomerBuys {
    items: DiscountItems!
    value: DiscountCustomerBuysValue!
}

input DiscountCustomerBuysInput {
    value: DiscountCustomerBuysValueInput
    items: DiscountItemsInput
}

union DiscountCustomerBuysValue = DiscountPurchaseAmount | DiscountQuantity

input DiscountCustomerBuysValueInput {
    quantity: UnsignedInt64
    amount: Decimal
}

type DiscountCustomerGets {
    appliesOnOneTimePurchase: Boolean!
    appliesOnSubscription: Boolean!
    items: DiscountItems!
    value: DiscountCustomerGetsValue!
}

input DiscountCustomerGetsInput {
    value: DiscountCustomerGetsValueInput
    items: DiscountItemsInput
    appliesOnOneTimePurchase: Boolean
    appliesOnSubscription: Boolean
}

union DiscountCustomerGetsValue = DiscountAmount | DiscountOnQuantity | DiscountPercentage

input DiscountCustomerGetsValueInput {
    discountOnQuantity: DiscountOnQuantityInput
    percentage: Float
    discountAmount: DiscountAmountInput
}

type DiscountCustomers {
    customers: [Customer!]!
}

type DiscountCustomerSavedSearches {
    savedSearches: [SavedSearch!]!
}

input DiscountCustomerSavedSearchesInput {
    add: [ID!]
    remove: [ID!]
}

union DiscountCustomerSelection = DiscountCustomerAll | DiscountCustomerSavedSearches | DiscountCustomers

input DiscountCustomerSelectionInput {
    all: Boolean
    customers: DiscountCustomersInput
    customerSavedSearches: DiscountCustomerSavedSearchesInput
}

input DiscountCustomersInput {
    add: [ID!]
    remove: [ID!]
}

union DiscountEffect = DiscountPercentage

input DiscountEffectInput {
    percentage: Float
}

enum DiscountErrorCode {
    BLANK
    PRESENT
    EQUAL_TO
    GREATER_THAN
    GREATER_THAN_OR_EQUAL_TO
    INVALID
    LESS_THAN_OR_EQUAL_TO
    LESS_THAN
    TAKEN
    TOO_LONG
    TOO_SHORT
    INTERNAL_ERROR
    TOO_MANY_ARGUMENTS
    MISSING_ARGUMENT
    VALUE_OUTSIDE_RANGE
    MINIMUM_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT
    EXCEEDED_MAX
    ACTIVE_PERIOD_OVERLAP
    CONFLICT
    IMPLICIT_DUPLICATE
    DUPLICATE
    INCLUSION
}

union DiscountItems = AllDiscountItems | DiscountCollections | DiscountProducts

input DiscountItemsInput {
    products: DiscountProductsInput
    collections: DiscountCollectionsInput
    all: Boolean
}

type DiscountMinimumQuantity {
    greaterThanOrEqualToQuantity: UnsignedInt64!
}

input DiscountMinimumQuantityInput {
    greaterThanOrEqualToQuantity: UnsignedInt64
}

union DiscountMinimumRequirement = DiscountMinimumQuantity | DiscountMinimumSubtotal

input DiscountMinimumRequirementInput {
    quantity: DiscountMinimumQuantityInput
    subtotal: DiscountMinimumSubtotalInput
}

type DiscountMinimumSubtotal {
    greaterThanOrEqualToSubtotal: MoneyV2!
}

input DiscountMinimumSubtotalInput {
    greaterThanOrEqualToSubtotal: Decimal
}

type DiscountOnQuantity {
    effect: DiscountEffect!
    quantity: DiscountQuantity!
}

input DiscountOnQuantityInput {
    quantity: UnsignedInt64
    effect: DiscountEffectInput
}

type DiscountPercentage {
    percentage: Float!
}

type DiscountProducts {
    productVariants(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductVariantConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductConnection!
}

input DiscountProductsInput {
    productsToAdd: [ID!]
    productsToRemove: [ID!]
    productVariantsToAdd: [ID!]
    productVariantsToRemove: [ID!]
}

type DiscountPurchaseAmount {
    amount: Decimal!
}

type DiscountQuantity {
    quantity: UnsignedInt64!
}

type DiscountRedeemCode {
    asyncUsageCount: Int!
    code: String!
    createdBy: App
    id: ID!
}

type DiscountRedeemCodeBulkAddPayload {
    bulkCreation: DiscountRedeemCodeBulkCreation
    userErrors: [DiscountUserError!]!
}

type DiscountRedeemCodeBulkCreation implements Node {
    codes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): DiscountRedeemCodeBulkCreationCodeConnection!
    codesCount: Int!
    createdAt: DateTime!
    discountCode: DiscountCodeNode
    done: Boolean!
    failedCount: Int!
    id: ID!
    importedCount: Int!
}

type DiscountRedeemCodeBulkCreationCode {
    code: String!
    discountRedeemCode: DiscountRedeemCode
    errors: [DiscountUserError!]!
}

type DiscountRedeemCodeBulkCreationCodeConnection {
    edges: [DiscountRedeemCodeBulkCreationCodeEdge!]!
    pageInfo: PageInfo!
}

type DiscountRedeemCodeBulkCreationCodeEdge {
    cursor: String!
    node: DiscountRedeemCodeBulkCreationCode!
}

type DiscountRedeemCodeConnection {
    edges: [DiscountRedeemCodeEdge!]!
    pageInfo: PageInfo!
}

type DiscountRedeemCodeEdge {
    cursor: String!
    node: DiscountRedeemCode!
}

input DiscountRedeemCodeInput {
    code: String!
}

type DiscountShareableUrl {
    targetItemImage: Image
    targetType: DiscountShareableUrlTargetType!
    title: String!
    url: URL!
}

enum DiscountShareableUrlTargetType {
    HOME
    PRODUCT
    COLLECTION
}

union DiscountShippingDestinationSelection = DiscountCountries | DiscountCountryAll

input DiscountShippingDestinationSelectionInput {
    all: Boolean = false
    countries: DiscountCountriesInput
}

enum DiscountStatus {
    ACTIVE
    EXPIRED
    SCHEDULED
}

enum DiscountTargetType {
    LINE_ITEM
    SHIPPING_LINE
}

enum DiscountType {
    MANUAL
    CODE_DISCOUNT
}

type DiscountUserError implements DisplayableError {
    code: DiscountErrorCode
    extraInfo: String
    field: [String!]
    message: String!
}

interface DisplayableError {
    field: [String!]
    message: String!
}

enum DisputeStatus {
    NEEDS_RESPONSE
    UNDER_REVIEW
    CHARGE_REFUNDED
    ACCEPTED
    WON
    LOST
}

enum DisputeType {
    CHARGEBACK
    INQUIRY
}

type Domain implements Node {
    host: String!
    id: ID!
    localization: DomainLocalization
    sslEnabled: Boolean!
    url: URL!
}

type DomainLocalization {
    alternateLocales: [String!]!
    country: String
    defaultLocale: String!
}

type DraftFulfillment {
    allowLabelPurchase: Boolean!
    lineItems: [LineItem!]!
    requiresShipping: Boolean!
    service: FulfillmentService!
}

type DraftOrder implements Node & HasMetafields & CommentEventSubject & LegacyInteroperability & HasEvents & HasLocalizationExtensionsForDraftOrders {
    appliedDiscount: DraftOrderAppliedDiscount
    billingAddress: MailingAddress
    completedAt: DateTime
    createdAt: DateTime!
    currencyCode: CurrencyCode!
    customAttributes: [Attribute!]!
    customer: Customer
    email: String
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
    hasTimelineComment: Boolean!
    id: ID!
    invoiceSentAt: DateTime
    invoiceUrl: URL
    legacyResourceId: UnsignedInt64!
    lineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): DraftOrderLineItemConnection!
    localizationExtensions(countryCodes: [CountryCode!], purposes: [LocalizationExtensionPurpose!], first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LocalizationExtensionConnection!
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    name: String!
    note2: String
    order: Order
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    ready: Boolean!
    shippingAddress: MailingAddress
    shippingLine: ShippingLine
    status: DraftOrderStatus!
    subtotalPrice: Money!
    tags: [String!]!
    taxExempt: Boolean!
    taxLines: [TaxLine!]!
    taxesIncluded: Boolean!
    totalPrice: Money!
    totalShippingPrice: Money!
    totalTax: Money!
    totalWeight: UnsignedInt64!
    updatedAt: DateTime!
}

type DraftOrderAppliedDiscount {
    amount: Money! @deprecated(reason: "Use `amountV2` instead")
    amountV2: MoneyV2!
    description: String!
    title: String
    value: Float!
    valueType: DraftOrderAppliedDiscountType!
}

input DraftOrderAppliedDiscountInput {
    amount: Money
    description: String
    title: String
    value: Float!
    valueType: DraftOrderAppliedDiscountType!
}

enum DraftOrderAppliedDiscountType {
    FIXED_AMOUNT
    PERCENTAGE
}

type DraftOrderCalculatePayload {
    calculatedDraftOrder: CalculatedDraftOrder
    userErrors: [UserError!]!
}

type DraftOrderCompletePayload {
    draftOrder: DraftOrder
    userErrors: [UserError!]!
}

type DraftOrderConnection {
    edges: [DraftOrderEdge!]!
    pageInfo: PageInfo!
}

type DraftOrderCreatePayload {
    draftOrder: DraftOrder
    userErrors: [UserError!]!
}

input DraftOrderDeleteInput {
    id: ID!
}

type DraftOrderDeletePayload {
    deletedId: ID
    userErrors: [UserError!]!
}

type DraftOrderEdge {
    cursor: String!
    node: DraftOrder!
}

input DraftOrderInput {
    appliedDiscount: DraftOrderAppliedDiscountInput
    billingAddress: MailingAddressInput
    customerId: ID
    customAttributes: [AttributeInput!]
    email: String
    lineItems: [DraftOrderLineItemInput!]
    metafields: [MetafieldInput!]
    privateMetafields: [PrivateMetafieldInput!]
    localizationExtensions: [LocalizationExtensionInput!]
    note: String
    shippingAddress: MailingAddressInput
    shippingLine: ShippingLineInput
    tags: [String!]
    taxExempt: Boolean
    useCustomerDefaultAddress: Boolean
}

type DraftOrderInvoicePreviewPayload {
    previewHtml: HTML
    userErrors: [UserError!]!
}

type DraftOrderInvoiceSendPayload {
    draftOrder: DraftOrder
    userErrors: [UserError!]!
}

type DraftOrderLineItem implements Node {
    appliedDiscount: DraftOrderAppliedDiscount
    custom: Boolean!
    customAttributes: [Attribute!]!
    discountedTotal: Money!
    discountedUnitPrice: Money!
    fulfillmentService: FulfillmentService!
    grams: Int @deprecated(reason: "Use `weight` instead")
    id: ID!
    image(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    isGiftCard: Boolean!
    name: String!
    originalTotal: Money!
    originalUnitPrice: Money!
    product: Product
    quantity: Int!
    requiresShipping: Boolean!
    sku: String
    taxLines: [TaxLine!]!
    taxable: Boolean!
    title: String!
    totalDiscount: Money!
    variant: ProductVariant
    variantTitle: String
    vendor: String
    weight: Weight
}

type DraftOrderLineItemConnection {
    edges: [DraftOrderLineItemEdge!]!
    pageInfo: PageInfo!
}

type DraftOrderLineItemEdge {
    cursor: String!
    node: DraftOrderLineItem!
}

input DraftOrderLineItemInput {
    appliedDiscount: DraftOrderAppliedDiscountInput
    customAttributes: [AttributeInput!]
    grams: Int
    originalUnitPrice: Money
    quantity: Int!
    requiresShipping: Boolean
    sku: String
    taxable: Boolean
    title: String
    variantId: ID
    weight: WeightInput
}

enum DraftOrderSortKeys {
    NUMBER
    UPDATED_AT
    STATUS
    TOTAL_PRICE
    CUSTOMER_NAME
    ID
    RELEVANCE
}

enum DraftOrderStatus {
    COMPLETED
    INVOICE_SENT
    OPEN
}

type DraftOrderUpdatePayload {
    draftOrder: DraftOrder
    userErrors: [UserError!]!
}

type Duty implements Node {
    countryCodeOfOrigin: CountryCode
    harmonizedSystemCode: String
    id: ID!
    price: MoneyBag!
    taxLines: [TaxLine!]!
}

type DutySale implements Sale {
    actionType: SaleActionType!
    duty: Duty!
    id: ID!
    lineType: SaleLineType!
    quantity: Int
    taxes: [SaleTax!]!
    totalAmount: MoneyBag!
    totalDiscountAmountAfterTaxes: MoneyBag!
    totalDiscountAmountBeforeTaxes: MoneyBag!
    totalTaxAmount: MoneyBag!
}

type EditableProperty {
    locked: Boolean!
    reason: FormattedString
}

input EmailInput {
    subject: String
    to: String
    from: String
    body: String
    bcc: [String!]
    customMessage: String
}

interface Event {
    appTitle: String
    attributeToApp: Boolean!
    attributeToUser: Boolean!
    createdAt: DateTime!
    criticalAlert: Boolean!
    id: ID!
    message: FormattedString!
}

type EventBridgeWebhookSubscriptionCreatePayload {
    userErrors: [UserError!]!
    webhookSubscription: WebhookSubscription
}

input EventBridgeWebhookSubscriptionInput {
    arn: ARN
    format: WebhookSubscriptionFormat
    includeFields: [String!]
    metafieldNamespaces: [String!]
}

type EventBridgeWebhookSubscriptionUpdatePayload {
    userErrors: [UserError!]!
    webhookSubscription: WebhookSubscription
}

type EventConnection {
    edges: [EventEdge!]!
    pageInfo: PageInfo!
}

type EventEdge {
    cursor: String!
    node: Event!
}

enum EventSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

type ExternalVideo implements Node & Media {
    alt: String
    embeddedUrl: URL!
    host: MediaHost!
    id: ID!
    mediaContentType: MediaContentType!
    mediaErrors: [MediaError!]!
    preview: MediaPreviewImage
    status: MediaStatus!
}

type FailedRequirement {
    action: NavigationItem
    message: String!
}

interface File {
    alt: String
    createdAt: DateTime!
    fileErrors: [FileError!]!
    fileStatus: FileStatus!
    preview: MediaPreviewImage
}

type FileConnection {
    edges: [FileEdge!]!
    pageInfo: PageInfo!
}

enum FileContentType {
    IMAGE
    FILE
}

input FileCreateInput {
    originalSource: String!
    contentType: FileContentType
    alt: String
}

type FileCreatePayload {
    files: [File!]
    userErrors: [FilesUserError!]!
}

type FileDeletePayload {
    deletedFileIds: [ID!]
    userErrors: [FilesUserError!]!
}

type FileEdge {
    cursor: String!
    node: File!
}

type FileError {
    code: FileErrorCode!
    details: String
    message: String!
}

enum FileErrorCode {
    UNKNOWN
    INVALID_SIGNED_URL
    IMAGE_DOWNLOAD_FAILURE
    IMAGE_PROCESSING_FAILURE
    MEDIA_TIMEOUT_ERROR
    EXTERNAL_VIDEO_NOT_FOUND
    EXTERNAL_VIDEO_UNLISTED
    EXTERNAL_VIDEO_INVALID_ASPECT_RATIO
    EXTERNAL_VIDEO_EMBED_DISABLED
    EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING
    GENERIC_FILE_DOWNLOAD_FAILURE
    GENERIC_FILE_INVALID_SIZE
    VIDEO_METADATA_READ_ERROR
    VIDEO_INVALID_FILETYPE_ERROR
    VIDEO_MIN_WIDTH_ERROR
    VIDEO_MAX_WIDTH_ERROR
    VIDEO_MIN_HEIGHT_ERROR
    VIDEO_MAX_HEIGHT_ERROR
    VIDEO_MIN_DURATION_ERROR
    VIDEO_MAX_DURATION_ERROR
    VIDEO_VALIDATION_ERROR
    MODEL3D_VALIDATION_ERROR
    MODEL3D_THUMBNAIL_GENERATION_ERROR
    MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR
    MODEL3D_GLB_OUTPUT_CREATION_ERROR
    UNSUPPORTED_IMAGE_FILE_TYPE
    INVALID_IMAGE_FILE_SIZE
    INVALID_IMAGE_ASPECT_RATIO
    INVALID_IMAGE_RESOLUTION
    FILE_STORAGE_LIMIT_EXCEEDED
}

enum FilesErrorCode {
    INVALID
    FILE_DOES_NOT_EXIST
    FILE_LOCKED
    TOO_MANY_ARGUMENTS
    BLANK_SEARCH
    MISSING_ARGUMENTS
    INVALID_QUERY
    UNACCEPTABLE_UNVERIFIED_TRIAL_ASSET
    UNACCEPTABLE_ASSET
    UNACCEPTABLE_TRIAL_ASSET
    ALT_VALUE_LIMIT_EXCEEDED
}

enum FileSortKeys {
    FILENAME
    ORIGINAL_UPLOAD_SIZE
    CREATED_AT
    ID
    RELEVANCE
}

enum FileStatus {
    UPLOADED
    PROCESSING
    READY
    FAILED
}

type FilesUserError implements DisplayableError {
    code: FilesErrorCode
    field: [String!]
    message: String!
}

input FileUpdateInput {
    id: ID!
    alt: String
}

type FileUpdatePayload {
    files: [File!]
    userErrors: [FilesUserError!]!
}

type FilterOption {
    label: String!
    value: String!
}

type FlowTriggerReceivePayload {
    userErrors: [UserError!]!
}

scalar FormattedString

type Fulfillment implements LegacyInteroperability & Node {
    createdAt: DateTime!
    deliveredAt: DateTime
    displayStatus: FulfillmentDisplayStatus
    estimatedDeliveryAt: DateTime
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: FulfillmentEventSortKeys = HAPPENED_AT): FulfillmentEventConnection!
    fulfillmentLineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): FulfillmentLineItemConnection!
    fulfillmentOrders(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): FulfillmentOrderConnection!
    id: ID!
    inTransitAt: DateTime
    legacyResourceId: UnsignedInt64!
    location: Location
    name: String!
    order: Order!
    requiresShipping: Boolean!
    service: FulfillmentService
    status: FulfillmentStatus!
    totalQuantity: Int!
    trackingInfo(first: Int): [FulfillmentTrackingInfo!]!
    updatedAt: DateTime!
}

type FulfillmentCancelPayload {
    fulfillment: Fulfillment
    userErrors: [UserError!]!
}

type FulfillmentConnection {
    edges: [FulfillmentEdge!]!
    pageInfo: PageInfo!
}

type FulfillmentCreatePayload {
    fulfillment: Fulfillment
    order: Order
    userErrors: [UserError!]!
}

type FulfillmentCreateV2Payload {
    fulfillment: Fulfillment
    userErrors: [UserError!]!
}

enum FulfillmentDisplayStatus {
    ATTEMPTED_DELIVERY
    CANCELED
    CONFIRMED
    DELIVERED
    FAILURE
    FULFILLED
    IN_TRANSIT
    LABEL_PRINTED
    LABEL_PURCHASED
    LABEL_VOIDED
    MARKED_AS_FULFILLED
    NOT_DELIVERED
    OUT_FOR_DELIVERY
    READY_FOR_PICKUP
    PICKED_UP
    SUBMITTED
}

type FulfillmentEdge {
    cursor: String!
    node: Fulfillment!
}

type FulfillmentEvent implements Node {
    happenedAt: DateTime!
    id: ID!
    status: FulfillmentEventStatus!
}

type FulfillmentEventConnection {
    edges: [FulfillmentEventEdge!]!
    pageInfo: PageInfo!
}

type FulfillmentEventEdge {
    cursor: String!
    node: FulfillmentEvent!
}

enum FulfillmentEventSortKeys {
    HAPPENED_AT
    ID
    RELEVANCE
}

enum FulfillmentEventStatus {
    LABEL_PURCHASED
    LABEL_PRINTED
    READY_FOR_PICKUP
    CONFIRMED
    IN_TRANSIT
    OUT_FOR_DELIVERY
    ATTEMPTED_DELIVERY
    DELIVERED
    FAILURE
}

input FulfillmentInput {
    orderId: ID!
    lineItems: [FulfillmentLineItemInput!]
    trackingNumbers: [String!]
    trackingUrls: [String!]
    trackingCompany: String
    notifyCustomer: Boolean
    shippingMethod: String
    locationId: ID!
}

type FulfillmentLineItem implements Node {
    discountedTotal: Money! @deprecated(reason: "Use `discountedTotalSet` instead")
    discountedTotalSet: MoneyBag!
    id: ID!
    lineItem: LineItem!
    originalTotal: Money! @deprecated(reason: "Use `originalTotalSet` instead")
    originalTotalSet: MoneyBag!
    quantity: Int
}

type FulfillmentLineItemConnection {
    edges: [FulfillmentLineItemEdge!]!
    pageInfo: PageInfo!
}

type FulfillmentLineItemEdge {
    cursor: String!
    node: FulfillmentLineItem!
}

input FulfillmentLineItemInput {
    id: ID!
    quantity: Int
}

type FulfillmentOrder implements Node {
    assignedLocation: FulfillmentOrderAssignedLocation!
    deliveryMethod: DeliveryMethod
    destination: FulfillmentOrderDestination
    fulfillAt: DateTime
    fulfillments(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): FulfillmentConnection!
    id: ID!
    internationalDuties: FulfillmentOrderInternationalDuties
    lineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): FulfillmentOrderLineItemConnection!
    locationsForMove(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): FulfillmentOrderLocationForMoveConnection!
    merchantRequests(kind: FulfillmentOrderMerchantRequestKind, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): FulfillmentOrderMerchantRequestConnection!
    order: Order!
    requestStatus: FulfillmentOrderRequestStatus!
    status: FulfillmentOrderStatus!
    supportedActions: [FulfillmentOrderSupportedAction!]!
}

type FulfillmentOrderAcceptCancellationRequestPayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderAcceptFulfillmentRequestPayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

enum FulfillmentOrderAction {
    CREATE_FULFILLMENT
    REQUEST_FULFILLMENT
    CANCEL_FULFILLMENT_ORDER
    MOVE
    REQUEST_CANCELLATION
    MARK_AS_OPEN
    EXTERNAL
}

type FulfillmentOrderAssignedLocation {
    address1: String
    address2: String
    city: String
    countryCode: CountryCode!
    location: Location
    name: String!
    phone: String
    province: String
    zip: String
}

enum FulfillmentOrderAssignmentStatus {
    CANCELLATION_REQUESTED
    FULFILLMENT_REQUESTED
    FULFILLMENT_ACCEPTED
}

type FulfillmentOrderCancelPayload {
    fulfillmentOrder: FulfillmentOrder
    replacementFulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderClosePayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderConnection {
    edges: [FulfillmentOrderEdge!]!
    pageInfo: PageInfo!
}

type FulfillmentOrderDestination implements Node {
    address1: String
    address2: String
    city: String
    company: String
    countryCode: CountryCode
    email: String
    firstName: String
    id: ID!
    lastName: String
    phone: String
    province: String
    zip: String
}

type FulfillmentOrderEdge {
    cursor: String!
    node: FulfillmentOrder!
}

type FulfillmentOrderInternationalDuties {
    incoterm: String!
}

type FulfillmentOrderLineItem implements Node {
    id: ID!
    lineItem: LineItem!
    remainingQuantity: Int!
    totalQuantity: Int!
}

type FulfillmentOrderLineItemConnection {
    edges: [FulfillmentOrderLineItemEdge!]!
    pageInfo: PageInfo!
}

type FulfillmentOrderLineItemEdge {
    cursor: String!
    node: FulfillmentOrderLineItem!
}

input FulfillmentOrderLineItemInput {
    id: ID!
    quantity: Int!
}

input FulfillmentOrderLineItemsInput {
    fulfillmentOrderId: ID!
    fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]
}

type FulfillmentOrderLocationForMove {
    location: Location!
    message: String
    movable: Boolean!
}

type FulfillmentOrderLocationForMoveConnection {
    edges: [FulfillmentOrderLocationForMoveEdge!]!
    pageInfo: PageInfo!
}

type FulfillmentOrderLocationForMoveEdge {
    cursor: String!
    node: FulfillmentOrderLocationForMove!
}

type FulfillmentOrderMerchantRequest implements Node {
    id: ID!
    kind: FulfillmentOrderMerchantRequestKind!
    message: String
    requestOptions: JSON
    responseData: JSON
    sentAt: DateTime!
}

type FulfillmentOrderMerchantRequestConnection {
    edges: [FulfillmentOrderMerchantRequestEdge!]!
    pageInfo: PageInfo!
}

type FulfillmentOrderMerchantRequestEdge {
    cursor: String!
    node: FulfillmentOrderMerchantRequest!
}

enum FulfillmentOrderMerchantRequestKind {
    FULFILLMENT_REQUEST
    CANCELLATION_REQUEST
}

type FulfillmentOrderMovePayload {
    movedFulfillmentOrder: FulfillmentOrder
    originalFulfillmentOrder: FulfillmentOrder
    remainingFulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderOpenPayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderRejectCancellationRequestPayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderRejectFulfillmentRequestPayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

enum FulfillmentOrderRequestStatus {
    UNSUBMITTED
    SUBMITTED
    ACCEPTED
    REJECTED
    CANCELLATION_REQUESTED
    CANCELLATION_ACCEPTED
    CANCELLATION_REJECTED
    CLOSED
}

type FulfillmentOrderReschedulePayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [FulfillmentOrderRescheduleUserError!]!
}

type FulfillmentOrderRescheduleUserError implements DisplayableError {
    code: FulfillmentOrderRescheduleUserErrorCode
    field: [String!]
    message: String!
}

enum FulfillmentOrderRescheduleUserErrorCode {
    FULFILLMENT_ORDER_NOT_FOUND
}

enum FulfillmentOrderSortKeys {
    ID
    RELEVANCE
}

enum FulfillmentOrderStatus {
    OPEN
    IN_PROGRESS
    CANCELLED
    INCOMPLETE
    CLOSED
    SCHEDULED
    ON_HOLD
}

type FulfillmentOrderSubmitCancellationRequestPayload {
    fulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderSubmitFulfillmentRequestPayload {
    originalFulfillmentOrder: FulfillmentOrder
    submittedFulfillmentOrder: FulfillmentOrder
    unsubmittedFulfillmentOrder: FulfillmentOrder
    userErrors: [UserError!]!
}

type FulfillmentOrderSupportedAction {
    action: FulfillmentOrderAction!
    externalUrl: URL
}

type FulfillmentService {
    callbackUrl: URL
    fulfillmentOrdersOptIn: Boolean!
    handle: String!
    id: ID!
    inventoryManagement: Boolean!
    location: Location
    productBased: Boolean!
    serviceName: String!
    shippingMethods: [ShippingMethod!]!
    type: FulfillmentServiceType!
}

type FulfillmentServiceCreatePayload {
    fulfillmentService: FulfillmentService
    userErrors: [UserError!]!
}

type FulfillmentServiceDeletePayload {
    deletedId: ID
    userErrors: [UserError!]!
}

enum FulfillmentServiceType {
    GIFT_CARD
    MANUAL
    THIRD_PARTY
}

type FulfillmentServiceUpdatePayload {
    fulfillmentService: FulfillmentService
    userErrors: [UserError!]!
}

enum FulfillmentStatus {
    PENDING
    OPEN
    SUCCESS
    CANCELLED
    ERROR
    FAILURE
}

type FulfillmentTrackingInfo {
    company: String
    number: String
    url: URL
}

type FulfillmentTrackingInfoUpdatePayload {
    fulfillment: Fulfillment
    userErrors: [UserError!]!
}

type FulfillmentTrackingInfoUpdateV2Payload {
    fulfillment: Fulfillment
    userErrors: [UserError!]!
}

input FulfillmentTrackingInput {
    number: String
    url: URL
    company: String
}

input FulfillmentV2Input {
    trackingInfo: FulfillmentTrackingInput
    notifyCustomer: Boolean = false
    lineItemsByFulfillmentOrder: [FulfillmentOrderLineItemsInput!]!
}

type GenericFile implements Node & File {
    alt: String
    createdAt: DateTime!
    fileErrors: [FileError!]!
    fileStatus: FileStatus!
    id: ID!
    preview: MediaPreviewImage
    url: URL
}

type GiftCard implements Node {
    balance: MoneyV2!
    createdAt: DateTime!
    customer: Customer
    disabledAt: DateTime
    enabled: Boolean!
    expiresOn: Date
    id: ID!
    initialValue: MoneyV2!
    lastCharacters: String!
    maskedCode: String!
    note: String
    order: Order
}

type GiftCardConnection {
    edges: [GiftCardEdge!]!
    pageInfo: PageInfo!
}

input GiftCardCreateInput {
    initialValue: Decimal!
    code: String
    customerId: ID
    expiresOn: Date
    note: String
    templateSuffix: String
}

type GiftCardCreatePayload {
    giftCard: GiftCard
    giftCardCode: String
    userErrors: [GiftCardUserError!]!
}

type GiftCardDisablePayload {
    giftCard: GiftCard
    userErrors: [UserError!]!
}

type GiftCardEdge {
    cursor: String!
    node: GiftCard!
}

enum GiftCardErrorCode {
    TOO_LONG
    TOO_SHORT
    TAKEN
    INVALID
    INTERNAL_ERROR
    MISSING_ARGUMENT
    GREATER_THAN
}

type GiftCardSale implements Sale {
    actionType: SaleActionType!
    id: ID!
    lineItem: LineItem!
    lineType: SaleLineType!
    quantity: Int
    taxes: [SaleTax!]!
    totalAmount: MoneyBag!
    totalDiscountAmountAfterTaxes: MoneyBag!
    totalDiscountAmountBeforeTaxes: MoneyBag!
    totalTaxAmount: MoneyBag!
}

enum GiftCardSortKeys {
    CREATED_AT
    UPDATED_AT
    CUSTOMER_NAME
    CODE
    BALANCE
    AMOUNT_SPENT
    INITIAL_VALUE
    DISABLED_AT
    EXPIRES_ON
    ID
    RELEVANCE
}

input GiftCardUpdateInput {
    note: String
    expiresOn: Date
    customerId: ID
    templateSuffix: String
}

type GiftCardUpdatePayload {
    giftCard: GiftCard
    userErrors: [UserError!]!
}

type GiftCardUserError implements DisplayableError {
    code: GiftCardErrorCode
    field: [String!]
    message: String!
}

interface HasEvents {
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
}

interface HasLocalizationExtensions {
    localizationExtensions(countryCodes: [CountryCode!], purposes: [LocalizationExtensionPurpose!], first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LocalizationExtensionConnection!
}

interface HasLocalizationExtensionsForDraftOrders {
    localizationExtensions(countryCodes: [CountryCode!], purposes: [LocalizationExtensionPurpose!], first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LocalizationExtensionConnection!
}

interface HasMetafields {
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
}

interface HasPublishedTranslations {
    translations(locale: String!): [PublishedTranslation!]!
}

scalar HTML

type Image implements HasMetafields {
    altText: String
    height: Int
    id: ID
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    originalSrc: URL!
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    src: URL! @deprecated(reason: "Previously an image had a single `src` field. This could either return the original image\nlocation or a URL that contained transformations such as sizing or scale.\n\nThese transformations were specified by arguments on the parent field.\n\nNow an image has two distinct URL fields: `originalSrc` and `transformedSrc`.\n\n* `originalSrc` - the original unmodified image URL\n* `transformedSrc` - the image URL with the specified transformations included\n\nTo migrate to the new fields, image transformations should be moved from the parent field to `transformedSrc`.\n\nBefore:\n```graphql\n{\n  shop {\n    productImages(maxWidth: 200, scale: 2) {\n      edges {\n        node {\n          src\n        }\n      }\n    }\n  }\n}\n```\n\nAfter:\n```graphql\n{\n  shop {\n    productImages {\n      edges {\n        node {\n          transformedSrc(maxWidth: 200, scale: 2)\n        }\n      }\n    }\n  }\n}\n```\n")
    transformedSrc(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1, preferredContentType: ImageContentType): URL!
    width: Int
}

type ImageConnection {
    edges: [ImageEdge!]!
    pageInfo: PageInfo!
}

enum ImageContentType {
    PNG
    JPG
    WEBP
}

type ImageEdge {
    cursor: String!
    node: Image!
}

input ImageInput {
    id: ID
    altText: String
    src: String
}

type ImageUploadParameter {
    name: String!
    value: String!
}

type InventoryActivatePayload {
    inventoryLevel: InventoryLevel
    userErrors: [UserError!]!
}

input InventoryAdjustItemInput {
    inventoryItemId: ID!
    availableDelta: Int!
}

input InventoryAdjustQuantityInput {
    inventoryLevelId: ID!
    availableDelta: Int!
}

type InventoryAdjustQuantityPayload {
    inventoryLevel: InventoryLevel
    userErrors: [UserError!]!
}

type InventoryBulkAdjustQuantityAtLocationPayload {
    inventoryLevels: [InventoryLevel!]
    userErrors: [UserError!]!
}

type InventoryDeactivatePayload {
    userErrors: [UserError!]!
}

type InventoryItem implements Node & LegacyInteroperability {
    countryCodeOfOrigin: CountryCode
    countryHarmonizedSystemCodes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CountryHarmonizedSystemCodeConnection!
    createdAt: DateTime!
    duplicateSkuCount: Int!
    harmonizedSystemCode: String
    id: ID!
    inventoryHistoryUrl: URL
    inventoryLevel(locationId: ID!): InventoryLevel
    inventoryLevels(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): InventoryLevelConnection!
    legacyResourceId: UnsignedInt64!
    locationsCount: Int!
    provinceCodeOfOrigin: String
    requiresShipping: Boolean!
    sku: String
    tracked: Boolean!
    trackedEditable: EditableProperty!
    unitCost: MoneyV2
    updatedAt: DateTime!
    variant: ProductVariant!
}

type InventoryItemConnection {
    edges: [InventoryItemEdge!]!
    pageInfo: PageInfo!
}

type InventoryItemEdge {
    cursor: String!
    node: InventoryItem!
}

input InventoryItemInput {
    cost: Decimal
    tracked: Boolean
}

input InventoryItemUpdateInput {
    cost: Decimal
    tracked: Boolean
    countryCodeOfOrigin: CountryCode
    provinceCodeOfOrigin: String
    harmonizedSystemCode: String
    countryHarmonizedSystemCodes: [CountryHarmonizedSystemCodeInput!]
}

type InventoryItemUpdatePayload {
    inventoryItem: InventoryItem
    userErrors: [UserError!]!
}

type InventoryLevel implements Node {
    available: Int!
    canDeactivate: Boolean!
    createdAt: DateTime!
    deactivationAlert: String
    deactivationAlertHtml: FormattedString
    id: ID!
    incoming: Int!
    item: InventoryItem!
    location: Location!
    updatedAt: DateTime!
}

type InventoryLevelConnection {
    edges: [InventoryLevelEdge!]!
    pageInfo: PageInfo!
}

type InventoryLevelEdge {
    cursor: String!
    node: InventoryLevel!
}

input InventoryLevelInput {
    availableQuantity: Int!
    locationId: ID!
}

type Job {
    done: Boolean!
    id: ID!
    query: QueryRoot
}

scalar JSON

enum KitSkillLocale {
    EN @deprecated(reason: "Kit Skills will be deprecated as of 2021-04-01.")
}

type KitSkillTriggerRequestPayload {
    conversationUid: String
    userErrors: [UserError!]!
}

interface LegacyInteroperability {
    legacyResourceId: UnsignedInt64!
}

type LimitedPendingOrderCount {
    atMax: Boolean!
    count: Int!
}

type LineItem implements Node {
    canRestock: Boolean! @deprecated(reason: "Use `restockable` instead")
    contract: SubscriptionContract
    currentQuantity: Int!
    customAttributes: [Attribute!]!
    discountAllocations: [DiscountAllocation!]!
    discountedTotal: Money! @deprecated(reason: "Use `discountedTotalSet` instead")
    discountedTotalSet: MoneyBag!
    discountedUnitPrice: Money! @deprecated(reason: "Use `discountedUnitPriceSet` instead")
    discountedUnitPriceSet: MoneyBag!
    duties: [Duty!]!
    fulfillableQuantity: Int!
    fulfillmentService: FulfillmentService!
    fulfillmentStatus: String!
    id: ID!
    image(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    merchantEditable: Boolean!
    name: String!
    nonFulfillableQuantity: Int!
    originalTotal: Money! @deprecated(reason: "Use `originalTotalSet` instead")
    originalTotalSet: MoneyBag!
    originalUnitPrice: Money! @deprecated(reason: "Use `originalUnitPriceSet` instead")
    originalUnitPriceSet: MoneyBag!
    product: Product
    quantity: Int!
    refundableQuantity: Int!
    requiresShipping: Boolean!
    restockable: Boolean!
    sellingPlan: LineItemSellingPlan
    sku: String
    taxLines(first: Int): [TaxLine!]!
    taxable: Boolean!
    title: String!
    totalDiscount: Money! @deprecated(reason: "Use `totalDiscountSet` instead")
    totalDiscountSet: MoneyBag!
    unfulfilledDiscountedTotal: Money! @deprecated(reason: "Use `unfulfilledDiscountedTotalSet` instead")
    unfulfilledDiscountedTotalSet: MoneyBag!
    unfulfilledOriginalTotal: Money! @deprecated(reason: "Use `unfulfilledOriginalTotalSet` instead")
    unfulfilledOriginalTotalSet: MoneyBag!
    unfulfilledQuantity: Int!
    variant: ProductVariant
    variantTitle: String
    vendor: String
}

type LineItemConnection {
    edges: [LineItemEdge!]!
    pageInfo: PageInfo!
}

type LineItemEdge {
    cursor: String!
    node: LineItem!
}

type LineItemMutable implements Node {
    canRestock: Boolean! @deprecated(reason: "Use `restockable` instead")
    customAttributes: [Attribute!]!
    discountAllocations: [DiscountAllocation!]!
    discountedTotal: Money! @deprecated(reason: "Use `discountedTotalSet` instead")
    discountedTotalSet: MoneyBag!
    discountedUnitPrice: Money! @deprecated(reason: "Use `discountedUnitPriceSet` instead")
    discountedUnitPriceSet: MoneyBag!
    fulfillableQuantity: Int!
    fulfillmentService: FulfillmentService!
    fulfillmentStatus: String!
    id: ID!
    image(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    merchantEditable: Boolean!
    name: String!
    nonFulfillableQuantity: Int!
    originalTotal: Money! @deprecated(reason: "Use `originalTotalSet` instead")
    originalTotalSet: MoneyBag!
    originalUnitPrice: Money! @deprecated(reason: "Use `originalUnitPriceSet` instead")
    originalUnitPriceSet: MoneyBag!
    product: Product
    quantity: Int!
    refundableQuantity: Int!
    requiresShipping: Boolean!
    restockable: Boolean!
    sku: String
    taxLines(first: Int): [TaxLine!]!
    taxable: Boolean!
    title: String!
    totalDiscount: Money! @deprecated(reason: "Use `totalDiscountSet` instead")
    totalDiscountSet: MoneyBag!
    unfulfilledDiscountedTotal: Money! @deprecated(reason: "Use `unfulfilledDiscountedTotalSet` instead")
    unfulfilledDiscountedTotalSet: MoneyBag!
    unfulfilledOriginalTotal: Money! @deprecated(reason: "Use `unfulfilledOriginalTotalSet` instead")
    unfulfilledOriginalTotalSet: MoneyBag!
    unfulfilledQuantity: Int!
    variant: ProductVariant
    variantTitle: String
    vendor: String
}

type LineItemMutableConnection {
    edges: [LineItemMutableEdge!]!
    pageInfo: PageInfo!
}

type LineItemMutableEdge {
    cursor: String!
    node: LineItemMutable!
}

type LineItemSellingPlan {
    name: String!
}

type Link implements HasPublishedTranslations {
    label: String!
    translations(locale: String!): [PublishedTranslation!]!
    url: URL!
}

type Locale {
    isoCode: String!
    name: String!
}

type LocalizationExtension {
    countryCode: CountryCode!
    key: LocalizationExtensionKey!
    purpose: LocalizationExtensionPurpose!
    title: String!
    value: String!
}

type LocalizationExtensionConnection {
    edges: [LocalizationExtensionEdge!]!
    pageInfo: PageInfo!
}

type LocalizationExtensionEdge {
    cursor: String!
    node: LocalizationExtension!
}

input LocalizationExtensionInput {
    key: LocalizationExtensionKey!
    value: String!
}

enum LocalizationExtensionKey {
    TAX_CREDENTIAL_BR
    SHIPPING_CREDENTIAL_BR
    SHIPPING_CREDENTIAL_CN
    TAX_CREDENTIAL_IT
    TAX_EMAIL_IT
    SHIPPING_CREDENTIAL_KR
}

enum LocalizationExtensionPurpose {
    SHIPPING
    TAX
}

type Location implements Node & LegacyInteroperability {
    activatable: Boolean!
    address: LocationAddress!
    addressVerified: Boolean!
    deactivatable: Boolean!
    deactivatedAt: String
    deletable: Boolean!
    fulfillmentService: FulfillmentService
    fulfillsOnlineOrders: Boolean!
    hasActiveInventory: Boolean!
    hasUnfulfilledOrders: Boolean!
    id: ID!
    inventoryLevel(inventoryItemId: ID!): InventoryLevel
    inventoryLevels(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): InventoryLevelConnection!
    isActive: Boolean!
    isPrimary: Boolean! @deprecated(reason: "The concept of a primary location is deprecated, shipsInventory can be used to get a fallback location")
    legacyResourceId: UnsignedInt64!
    name: String!
    shipsInventory: Boolean!
    suggestedAddresses: [LocationSuggestedAddress!]!
}

type LocationAddress {
    address1: String
    address2: String
    city: String
    country: String
    countryCode: String
    formatted: [String!]!
    latitude: Float
    longitude: Float
    phone: String
    province: String
    provinceCode: String
    zip: String
}

type LocationConnection {
    edges: [LocationEdge!]!
    pageInfo: PageInfo!
}

type LocationEdge {
    cursor: String!
    node: Location!
}

enum LocationSortKeys {
    NAME
    ID
    RELEVANCE
}

type LocationSuggestedAddress {
    address1: String
    address2: String
    city: String
    country: String
    countryCode: CountryCode
    formatted: [String!]!
    province: String
    provinceCode: String
    zip: String
}

type MailingAddress implements Node {
    address1: String
    address2: String
    city: String
    company: String
    country: String
    countryCode: String @deprecated(reason: "Use `countryCodeV2` instead")
    countryCodeV2: CountryCode
    firstName: String
    formatted(withName: Boolean = false, withCompany: Boolean = true): [String!]!
    formattedArea: String
    id: ID!
    lastName: String
    latitude: Float
    longitude: Float
    name: String
    phone: String
    province: String
    provinceCode: String
    zip: String
}

input MailingAddressInput {
    address1: String
    address2: String
    city: String
    company: String
    country: String
    countryCode: CountryCode
    firstName: String
    id: ID
    lastName: String
    phone: String
    province: String
    provinceCode: String
    zip: String
}

type ManualDiscountApplication implements DiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    description: String
    index: Int!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    title: String!
    value: PricingValue!
}

type MarketingActivity implements Node {
    activityListUrl: URL
    adSpend: MoneyV2
    app: App!
    appErrors: MarketingActivityExtensionAppErrors
    budget: MarketingBudget
    createdAt: DateTime!
    formData: String
    id: ID!
    marketingChannel: MarketingChannel!
    marketingEvent: MarketingEvent
    sourceAndMedium: String!
    status: MarketingActivityStatus!
    statusBadgeType: MarketingActivityStatusBadgeType
    statusLabel: String!
    statusTransitionedAt: DateTime
    tactic: MarketingTactic!
    targetStatus: MarketingActivityStatus
    title: String!
    updatedAt: DateTime!
    utmParameters: UTMParameters
}

input MarketingActivityBudgetInput {
    budgetType: MarketingBudgetBudgetType
    total: MoneyInput
}

type MarketingActivityConnection {
    edges: [MarketingActivityEdge!]!
    pageInfo: PageInfo!
}

input MarketingActivityCreateInput {
    marketingActivityTitle: String
    formData: String
    marketingActivityExtensionId: ID!
    context: String
    utm: UTMInput
    status: MarketingActivityStatus!
    budget: MarketingActivityBudgetInput
}

type MarketingActivityCreatePayload {
    marketingActivity: MarketingActivity
    redirectPath: String
    userErrors: [UserError!]!
}

type MarketingActivityEdge {
    cursor: String!
    node: MarketingActivity!
}

enum MarketingActivityExtensionAppErrorCode {
    NOT_ONBOARDED_ERROR
    VALIDATION_ERROR
    API_ERROR
    PLATFORM_ERROR
    INSTALL_REQUIRED_ERROR
}

type MarketingActivityExtensionAppErrors {
    code: MarketingActivityExtensionAppErrorCode!
    userErrors: [UserError!]!
}

enum MarketingActivitySortKeys {
    TITLE
    CREATED_AT
    ID
    RELEVANCE
}

enum MarketingActivityStatus {
    ACTIVE
    DELETED
    DELETED_EXTERNALLY
    DISCONNECTED
    DRAFT
    FAILED
    INACTIVE
    PAUSED
    PENDING
    SCHEDULED
    UNDEFINED
}

enum MarketingActivityStatusBadgeType {
    DEFAULT
    SUCCESS
    ATTENTION
    WARNING
    INFO
}

input MarketingActivityUpdateInput {
    id: ID!
    marketingRecommendationId: ID
    title: String
    budget: MarketingActivityBudgetInput
    adSpend: MoneyInput
    status: MarketingActivityStatus
    targetStatus: MarketingActivityStatus
    formData: String
    utm: UTMInput
    marketedResources: [ID!]
    context: String
    errors: JSON
}

type MarketingActivityUpdatePayload {
    marketingActivity: MarketingActivity
    redirectPath: String
    userErrors: [UserError!]!
}

type MarketingBudget {
    budgetType: MarketingBudgetBudgetType!
    total: MoneyV2!
}

enum MarketingBudgetBudgetType {
    DAILY
    LIFETIME
}

enum MarketingChannel {
    SEARCH
    DISPLAY
    SOCIAL
    EMAIL
    REFERRAL
}

type MarketingEngagement {
    adSpend: MoneyV2
    clicksCount: Int
    commentsCount: Int
    complaintsCount: Int
    failsCount: Int
    favoritesCount: Int
    fetchedAt: DateTime
    impressionsCount: Int
    isCumulative: Boolean
    marketingActivity: MarketingActivity!
    occurredOn: Date!
    sendsCount: Int
    sharesCount: Int
    uniqueClicksCount: Int
    uniqueViewsCount: Int
    unsubscribesCount: Int
    utcOffset: UtcOffset
    viewsCount: Int
}

type MarketingEngagementCreatePayload {
    marketingEngagement: MarketingEngagement
    userErrors: [UserError!]!
}

input MarketingEngagementInput {
    occurredOn: Date!
    impressionsCount: Int
    viewsCount: Int
    clicksCount: Int
    sharesCount: Int
    favoritesCount: Int
    commentsCount: Int
    unsubscribesCount: Int
    complaintsCount: Int
    failsCount: Int
    sendsCount: Int
    uniqueViewsCount: Int
    uniqueClicksCount: Int
    adSpend: MoneyInput
    isCumulative: Boolean
    utcOffset: UtcOffset
    fetchedAt: DateTime
}

type MarketingEvent implements Node & LegacyInteroperability {
    app: App!
    channel: MarketingChannel
    description: String
    endedAt: DateTime
    id: ID!
    legacyResourceId: UnsignedInt64!
    manageUrl: URL
    previewUrl: URL
    remoteId: String
    scheduledToEndAt: DateTime
    sourceAndMedium: String!
    startedAt: DateTime!
    targetTypeDisplayText: String! @deprecated(reason: "Use `sourceAndMedium` instead")
    type: MarketingTactic!
    utmCampaign: String
    utmMedium: String
    utmSource: String
}

type MarketingEventConnection {
    edges: [MarketingEventEdge!]!
    pageInfo: PageInfo!
}

type MarketingEventEdge {
    cursor: String!
    node: MarketingEvent!
}

enum MarketingEventSortKeys {
    STARTED_AT
    ID
    RELEVANCE
}

enum MarketingTactic {
    ABANDONED_CART
    AD
    AFFILIATE
    LINK
    LOYALTY
    MESSAGE
    NEWSLETTER
    NOTIFICATION
    POST
    RETARGETING
    TRANSACTIONAL
    SEO
    DIRECT
    STOREFRONT_APP
    DISPLAY @deprecated(reason: "`DISPLAY` is deprecated. Use `AD` instead.")
    SEARCH @deprecated(reason: "`SEARCH` is deprecated. Use `AD` instead.")
    FOLLOW_UP @deprecated(reason: "'FOLLOW_UP' is deprecated. Use 'TRANSACTIONAL' instead.")
    RECEIPT @deprecated(reason: "'RECEIPT' is deprecated. Use 'TRANSACTIONAL' instead.")
}

interface Media {
    alt: String
    mediaContentType: MediaContentType!
    mediaErrors: [MediaError!]!
    preview: MediaPreviewImage
    status: MediaStatus!
}

type MediaConnection {
    edges: [MediaEdge!]!
    pageInfo: PageInfo!
}

enum MediaContentType {
    VIDEO
    EXTERNAL_VIDEO
    MODEL_3D
    IMAGE
}

type MediaEdge {
    cursor: String!
    node: Media!
}

type MediaError {
    code: MediaErrorCode!
    details: String
    message: String!
}

enum MediaErrorCode {
    UNKNOWN
    INVALID_SIGNED_URL
    IMAGE_DOWNLOAD_FAILURE
    IMAGE_PROCESSING_FAILURE
    MEDIA_TIMEOUT_ERROR
    EXTERNAL_VIDEO_NOT_FOUND
    EXTERNAL_VIDEO_UNLISTED
    EXTERNAL_VIDEO_INVALID_ASPECT_RATIO
    EXTERNAL_VIDEO_EMBED_DISABLED
    EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING
    GENERIC_FILE_DOWNLOAD_FAILURE
    GENERIC_FILE_INVALID_SIZE
    VIDEO_METADATA_READ_ERROR
    VIDEO_INVALID_FILETYPE_ERROR
    VIDEO_MIN_WIDTH_ERROR
    VIDEO_MAX_WIDTH_ERROR
    VIDEO_MIN_HEIGHT_ERROR
    VIDEO_MAX_HEIGHT_ERROR
    VIDEO_MIN_DURATION_ERROR
    VIDEO_MAX_DURATION_ERROR
    VIDEO_VALIDATION_ERROR
    MODEL3D_VALIDATION_ERROR
    MODEL3D_THUMBNAIL_GENERATION_ERROR
    MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR
    MODEL3D_GLB_OUTPUT_CREATION_ERROR
    UNSUPPORTED_IMAGE_FILE_TYPE
    INVALID_IMAGE_FILE_SIZE
    INVALID_IMAGE_ASPECT_RATIO
    INVALID_IMAGE_RESOLUTION
    FILE_STORAGE_LIMIT_EXCEEDED
}

enum MediaHost {
    YOUTUBE
    VIMEO
}

type MediaImage implements Node & File & Media {
    alt: String
    createdAt: DateTime!
    fileErrors: [FileError!]!
    fileStatus: FileStatus!
    id: ID!
    image: Image
    mediaContentType: MediaContentType!
    mediaErrors: [MediaError!]!
    mimeType: String
    preview: MediaPreviewImage
    status: MediaStatus!
}

type MediaPreviewImage {
    image: Image
    status: MediaPreviewImageStatus!
}

enum MediaPreviewImageStatus {
    UPLOADED
    PROCESSING
    READY
    FAILED
}

enum MediaStatus {
    UPLOADED
    PROCESSING
    READY
    FAILED
}

type MediaUserError implements DisplayableError {
    code: MediaUserErrorCode
    field: [String!]
    message: String!
}

enum MediaUserErrorCode {
    INVALID
    BLANK
    VIDEO_VALIDATION_ERROR
    MODEL3D_VALIDATION_ERROR
    VIDEO_THROTTLE_EXCEEDED
    MODEL3D_THROTTLE_EXCEEDED
    PRODUCT_MEDIA_LIMIT_EXCEEDED
    SHOP_MEDIA_LIMIT_EXCEEDED
    PRODUCT_DOES_NOT_EXIST
    MEDIA_DOES_NOT_EXIST
    MEDIA_DOES_NOT_EXIST_ON_PRODUCT
    TOO_MANY_MEDIA_PER_INPUT_PAIR
    MAXIMUM_VARIANT_MEDIA_PAIRS_EXCEEDED
    INVALID_MEDIA_TYPE
    PRODUCT_VARIANT_SPECIFIED_MULTIPLE_TIMES
    PRODUCT_VARIANT_DOES_NOT_EXIST_ON_PRODUCT
    NON_READY_MEDIA
    PRODUCT_VARIANT_ALREADY_HAS_MEDIA
    MEDIA_IS_NOT_ATTACHED_TO_VARIANT
    MEDIA_CANNOT_BE_MODIFIED
}

type Metafield implements Node & LegacyInteroperability {
    createdAt: DateTime!
    description: String
    id: ID!
    key: String!
    legacyResourceId: UnsignedInt64!
    namespace: String!
    ownerType: MetafieldOwnerType!
    type: String!
    updatedAt: DateTime!
    value: String!
    valueType: MetafieldValueType! @deprecated(reason: "`valueType` is deprecated and replaced by `type` in API version 2021-07.")
}

type MetafieldConnection {
    edges: [MetafieldEdge!]!
    pageInfo: PageInfo!
}

input MetafieldDeleteInput {
    id: ID!
}

type MetafieldDeletePayload {
    deletedId: ID
    userErrors: [UserError!]!
}

type MetafieldEdge {
    cursor: String!
    node: Metafield!
}

input MetafieldInput {
    description: String
    id: ID
    key: String
    namespace: String
    value: String
    type: String
}

enum MetafieldOwnerType {
    ARTICLE
    BLOG
    COLLECTION
    CUSTOMER
    DRAFTORDER
    ORDER
    PAGE
    PRODUCT
    PRODUCTIMAGE
    PRODUCTVARIANT
    SHOP
}

type MetafieldStorefrontVisibility implements Node & LegacyInteroperability {
    createdAt: DateTime!
    id: ID!
    key: String!
    legacyResourceId: UnsignedInt64!
    namespace: String!
    ownerType: MetafieldOwnerType!
    updatedAt: DateTime!
}

type MetafieldStorefrontVisibilityConnection {
    edges: [MetafieldStorefrontVisibilityEdge!]!
    pageInfo: PageInfo!
}

type MetafieldStorefrontVisibilityCreatePayload {
    metafieldStorefrontVisibility: MetafieldStorefrontVisibility
    userErrors: [UserError!]!
}

type MetafieldStorefrontVisibilityDeletePayload {
    deletedMetafieldStorefrontVisibilityId: ID
    userErrors: [UserError!]!
}

type MetafieldStorefrontVisibilityEdge {
    cursor: String!
    node: MetafieldStorefrontVisibility!
}

input MetafieldStorefrontVisibilityInput {
    namespace: String!
    key: String!
    ownerType: MetafieldOwnerType!
}

enum MetafieldValueType {
    STRING
    INTEGER
    JSON_STRING
}

enum MethodDefinitionSortKeys {
    RATE_PROVIDER_TYPE
    ID
    RELEVANCE
}

type Model3d implements Node & Media {
    alt: String
    filename: String!
    id: ID!
    mediaContentType: MediaContentType!
    mediaErrors: [MediaError!]!
    originalSource: Model3dSource
    preview: MediaPreviewImage
    sources: [Model3dSource!]!
    status: MediaStatus!
}

type Model3dSource {
    filesize: Int!
    format: String!
    mimeType: String!
    url: String!
}

scalar Money

type MoneyBag {
    presentmentMoney: MoneyV2!
    shopMoney: MoneyV2!
}

input MoneyInput {
    amount: Decimal!
    currencyCode: CurrencyCode!
}

type MoneyV2 {
    amount: Decimal!
    currencyCode: CurrencyCode!
}

input MoveInput {
    id: ID!
    newPosition: UnsignedInt64!
}

type Mutation {
    appCreditCreate(description: String!, amount: MoneyInput!, test: Boolean = false): AppCreditCreatePayload
    appPurchaseOneTimeCreate(name: String!, price: MoneyInput!, returnUrl: URL!, test: Boolean = false): AppPurchaseOneTimeCreatePayload
    appRevenueAttributionRecordCreate(appRevenueAttributionRecord: AppRevenueAttributionRecordInput!): AppRevenueAttributionRecordCreatePayload
    appRevenueAttributionRecordDelete(id: ID!): AppRevenueAttributionRecordDeletePayload
    appSubscriptionCancel(id: ID!): AppSubscriptionCancelPayload
    appSubscriptionCreate(name: String!, lineItems: [AppSubscriptionLineItemInput!]!, test: Boolean, trialDays: Int, returnUrl: URL!): AppSubscriptionCreatePayload
    appSubscriptionLineItemUpdate(id: ID!, cappedAmount: MoneyInput!): AppSubscriptionLineItemUpdatePayload
    appUsageRecordCreate(subscriptionLineItemId: ID!, price: MoneyInput!, description: String!): AppUsageRecordCreatePayload
    bulkOperationCancel(id: ID!): BulkOperationCancelPayload
    bulkOperationRunMutation(mutation: String!, stagedUploadPath: String!, clientIdentifier: String): BulkOperationRunMutationPayload
    bulkOperationRunQuery(query: String!): BulkOperationRunQueryPayload
    captureSessionReject(id: ID!, reason: CaptureSessionRejectionReasonInput!): CaptureSessionRejectPayload
    captureSessionResolve(id: ID!): CaptureSessionResolvePayload
    collectionAddProducts(id: ID!, productIds: [ID!]!): CollectionAddProductsPayload
    collectionCreate(input: CollectionInput!): CollectionCreatePayload
    collectionDelete(input: CollectionDeleteInput!): CollectionDeletePayload
    collectionPublish(input: CollectionPublishInput!): CollectionPublishPayload @deprecated(reason: "Use `publishablePublish` instead")
    collectionRemoveProducts(id: ID!, productIds: [ID!]!): CollectionRemoveProductsPayload
    collectionReorderProducts(id: ID!, moves: [MoveInput!]!): CollectionReorderProductsPayload
    collectionUnpublish(input: CollectionUnpublishInput!): CollectionUnpublishPayload @deprecated(reason: "Use `publishableUnpublish` instead")
    collectionUpdate(input: CollectionInput!): CollectionUpdatePayload
    customerAddTaxExemptions(customerId: ID!, taxExemptions: [TaxExemption!]!): CustomerAddTaxExemptionsPayload
    customerCreate(input: CustomerInput!): CustomerCreatePayload
    customerDelete(input: CustomerDeleteInput!): CustomerDeletePayload
    customerGenerateAccountActivationUrl(customerId: ID!): CustomerGenerateAccountActivationUrlPayload
    customerPaymentMethodCreditCardCreate(customerId: ID!, billingAddress: MailingAddressInput!, sessionId: String!): CustomerPaymentMethodCreditCardCreatePayload
    customerPaymentMethodCreditCardUpdate(id: ID!, billingAddress: MailingAddressInput!, sessionId: String!): CustomerPaymentMethodCreditCardUpdatePayload
    customerPaymentMethodPaypalBillingAgreementCreate(customerId: ID!, billingAddress: MailingAddressInput, billingAgreementId: String!, inactive: Boolean = false): CustomerPaymentMethodPaypalBillingAgreementCreatePayload
    customerPaymentMethodPaypalBillingAgreementUpdate(id: ID!, billingAddress: MailingAddressInput!): CustomerPaymentMethodPaypalBillingAgreementUpdatePayload
    customerPaymentMethodRemoteCreate(customerId: ID!, remoteReference: CustomerPaymentMethodRemoteInput!): CustomerPaymentMethodRemoteCreatePayload
    customerPaymentMethodRemoteCreditCardCreate(customerId: ID!, stripeCustomerId: String!, stripePaymentMethodId: String): CustomerPaymentMethodRemoteCreditCardCreatePayload @deprecated(reason: "Use `customerPaymentMethodRemoteCreate` instead")
    customerPaymentMethodRevoke(customerPaymentMethodId: ID!): CustomerPaymentMethodRevokePayload
    customerPaymentMethodSendUpdateEmail(customerPaymentMethodId: ID!, email: EmailInput): CustomerPaymentMethodSendUpdateEmailPayload
    customerRemoveTaxExemptions(customerId: ID!, taxExemptions: [TaxExemption!]!): CustomerRemoveTaxExemptionsPayload
    customerReplaceTaxExemptions(customerId: ID!, taxExemptions: [TaxExemption!]!): CustomerReplaceTaxExemptionsPayload
    customerUpdate(input: CustomerInput!): CustomerUpdatePayload
    customerUpdateDefaultAddress(customerId: ID!, addressId: ID!): CustomerUpdateDefaultAddressPayload
    deliveryProfileCreate(profile: DeliveryProfileInput!): deliveryProfileCreatePayload
    deliveryProfileRemove(id: ID!): deliveryProfileRemovePayload
    deliveryProfileUpdate(id: ID!, profile: DeliveryProfileInput!, leaveLegacyModeProfiles: Boolean): deliveryProfileUpdatePayload
    deliverySettingUpdate(setting: DeliverySettingInput!): DeliverySettingUpdatePayload
    deliveryShippingOriginAssign(locationId: ID!): DeliveryShippingOriginAssignPayload
    discountAutomaticActivate(id: ID!): DiscountAutomaticActivatePayload
    discountAutomaticBasicCreate(automaticBasicDiscount: DiscountAutomaticBasicInput!): DiscountAutomaticBasicCreatePayload
    discountAutomaticBasicUpdate(id: ID!, automaticBasicDiscount: DiscountAutomaticBasicInput!): DiscountAutomaticBasicUpdatePayload
    discountAutomaticBulkDelete(search: String, savedSearchId: ID, ids: [ID!]): DiscountAutomaticBulkDeletePayload
    discountAutomaticBxgyCreate(automaticBxgyDiscount: DiscountAutomaticBxgyInput!): DiscountAutomaticBxgyCreatePayload
    discountAutomaticBxgyUpdate(id: ID!, automaticBxgyDiscount: DiscountAutomaticBxgyInput!): DiscountAutomaticBxgyUpdatePayload
    discountAutomaticDeactivate(id: ID!): DiscountAutomaticDeactivatePayload
    discountAutomaticDelete(id: ID!): DiscountAutomaticDeletePayload
    discountCodeActivate(id: ID!): DiscountCodeActivatePayload
    discountCodeBasicCreate(basicCodeDiscount: DiscountCodeBasicInput!): DiscountCodeBasicCreatePayload
    discountCodeBasicUpdate(id: ID!, basicCodeDiscount: DiscountCodeBasicInput!): DiscountCodeBasicUpdatePayload
    discountCodeBulkActivate(search: String, savedSearchId: ID, ids: [ID!]): DiscountCodeBulkActivatePayload
    discountCodeBulkDeactivate(search: String, savedSearchId: ID, ids: [ID!]): DiscountCodeBulkDeactivatePayload
    discountCodeBulkDelete(search: String, savedSearchId: ID, ids: [ID!]): DiscountCodeBulkDeletePayload
    discountCodeBxgyCreate(bxgyCodeDiscount: DiscountCodeBxgyInput!): DiscountCodeBxgyCreatePayload
    discountCodeBxgyUpdate(id: ID!, bxgyCodeDiscount: DiscountCodeBxgyInput!): DiscountCodeBxgyUpdatePayload
    discountCodeDeactivate(id: ID!): DiscountCodeDeactivatePayload
    discountCodeDelete(id: ID!): DiscountCodeDeletePayload
    discountCodeFreeShippingCreate(freeShippingCodeDiscount: DiscountCodeFreeShippingInput!): DiscountCodeFreeShippingCreatePayload
    discountCodeFreeShippingUpdate(id: ID!, freeShippingCodeDiscount: DiscountCodeFreeShippingInput!): DiscountCodeFreeShippingUpdatePayload
    discountCodeRedeemCodeBulkDelete(discountId: ID!, search: String, savedSearchId: ID, ids: [ID!]): DiscountCodeRedeemCodeBulkDeletePayload
    discountRedeemCodeBulkAdd(discountId: ID!, codes: [DiscountRedeemCodeInput!]!): DiscountRedeemCodeBulkAddPayload
    draftOrderCalculate(input: DraftOrderInput!): DraftOrderCalculatePayload
    draftOrderComplete(id: ID!, paymentPending: Boolean = false): DraftOrderCompletePayload
    draftOrderCreate(input: DraftOrderInput!): DraftOrderCreatePayload
    draftOrderDelete(input: DraftOrderDeleteInput!): DraftOrderDeletePayload
    draftOrderInvoicePreview(id: ID!, email: EmailInput): DraftOrderInvoicePreviewPayload
    draftOrderInvoiceSend(id: ID!, email: EmailInput): DraftOrderInvoiceSendPayload
    draftOrderUpdate(id: ID!, input: DraftOrderInput!): DraftOrderUpdatePayload
    eventBridgeWebhookSubscriptionCreate(topic: WebhookSubscriptionTopic!, webhookSubscription: EventBridgeWebhookSubscriptionInput!): EventBridgeWebhookSubscriptionCreatePayload
    eventBridgeWebhookSubscriptionUpdate(id: ID!, webhookSubscription: EventBridgeWebhookSubscriptionInput!): EventBridgeWebhookSubscriptionUpdatePayload
    fileCreate(files: [FileCreateInput!]!): FileCreatePayload
    fileDelete(fileIds: [ID!]!): FileDeletePayload
    fileUpdate(files: [FileUpdateInput!]!): FileUpdatePayload
    flowTriggerReceive(body: String!): FlowTriggerReceivePayload
    fulfillmentCancel(id: ID!): FulfillmentCancelPayload
    fulfillmentCreate(input: FulfillmentInput!): FulfillmentCreatePayload @deprecated(reason: "Use the new [fulfillmentOrder](https://shopify.dev/tutorials/manage-fulfillments-with-fulfillment-and-fulfillmentorder-resources) APIs to manage fulfillments.")
    fulfillmentCreateV2(fulfillment: FulfillmentV2Input!, message: String): FulfillmentCreateV2Payload
    fulfillmentOrderAcceptCancellationRequest(id: ID!, message: String): FulfillmentOrderAcceptCancellationRequestPayload
    fulfillmentOrderAcceptFulfillmentRequest(id: ID!, message: String): FulfillmentOrderAcceptFulfillmentRequestPayload
    fulfillmentOrderCancel(id: ID!): FulfillmentOrderCancelPayload
    fulfillmentOrderClose(id: ID!, message: String): FulfillmentOrderClosePayload
    fulfillmentOrderMove(id: ID!, newLocationId: ID!): FulfillmentOrderMovePayload
    fulfillmentOrderOpen(id: ID!): FulfillmentOrderOpenPayload
    fulfillmentOrderRejectCancellationRequest(id: ID!, message: String): FulfillmentOrderRejectCancellationRequestPayload
    fulfillmentOrderRejectFulfillmentRequest(id: ID!, message: String): FulfillmentOrderRejectFulfillmentRequestPayload
    fulfillmentOrderReschedule(id: ID!, fulfillAt: DateTime!): FulfillmentOrderReschedulePayload
    fulfillmentOrderSubmitCancellationRequest(id: ID!, message: String): FulfillmentOrderSubmitCancellationRequestPayload
    fulfillmentOrderSubmitFulfillmentRequest(id: ID!, message: String, notifyCustomer: Boolean, fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!], shippingMethod: String): FulfillmentOrderSubmitFulfillmentRequestPayload
    fulfillmentServiceCreate(name: String!, callbackUrl: URL, trackingSupport: Boolean = false, fulfillmentOrdersOptIn: Boolean = false, inventoryManagement: Boolean = false): FulfillmentServiceCreatePayload
    fulfillmentServiceDelete(id: ID!, destinationLocationId: ID): FulfillmentServiceDeletePayload
    fulfillmentServiceUpdate(id: ID!, name: String, callbackUrl: URL, trackingSupport: Boolean, fulfillmentOrdersOptIn: Boolean): FulfillmentServiceUpdatePayload
    fulfillmentTrackingInfoUpdate(fulfillmentId: ID!, trackingInfoUpdateInput: TrackingInfoUpdateInput!): FulfillmentTrackingInfoUpdatePayload @deprecated(reason: "Use the new [fulfillmentOrder](https://shopify.dev/tutorials/manage-fulfillments-with-fulfillment-and-fulfillmentorder-resources) APIs to manage fulfillments.")
    fulfillmentTrackingInfoUpdateV2(fulfillmentId: ID!, trackingInfoInput: FulfillmentTrackingInput!, notifyCustomer: Boolean): FulfillmentTrackingInfoUpdateV2Payload
    giftCardCreate(input: GiftCardCreateInput!): GiftCardCreatePayload
    giftCardDisable(id: ID!): GiftCardDisablePayload
    giftCardUpdate(id: ID!, input: GiftCardUpdateInput!): GiftCardUpdatePayload
    inventoryActivate(inventoryItemId: ID!, locationId: ID!, available: Int): InventoryActivatePayload
    inventoryAdjustQuantity(input: InventoryAdjustQuantityInput!): InventoryAdjustQuantityPayload
    inventoryBulkAdjustQuantityAtLocation(inventoryItemAdjustments: [InventoryAdjustItemInput!]!, locationId: ID!): InventoryBulkAdjustQuantityAtLocationPayload
    inventoryDeactivate(inventoryLevelId: ID!): InventoryDeactivatePayload
    inventoryItemUpdate(id: ID!, input: InventoryItemUpdateInput!): InventoryItemUpdatePayload
    kitSkillTriggerRequest(id: ID!, locale: KitSkillLocale!, placeholders: JSON = "{}"): KitSkillTriggerRequestPayload @deprecated(reason: "Kit Skills will be deprecated as of 2021-04-01.")
    marketingActivityCreate(input: MarketingActivityCreateInput!): MarketingActivityCreatePayload
    marketingActivityUpdate(input: MarketingActivityUpdateInput!): MarketingActivityUpdatePayload
    marketingEngagementCreate(marketingActivityId: ID!, marketingEngagement: MarketingEngagementInput!): MarketingEngagementCreatePayload
    metafieldDelete(input: MetafieldDeleteInput!): MetafieldDeletePayload
    metafieldStorefrontVisibilityCreate(input: MetafieldStorefrontVisibilityInput!): MetafieldStorefrontVisibilityCreatePayload
    metafieldStorefrontVisibilityDelete(id: ID!): MetafieldStorefrontVisibilityDeletePayload
    orderCapture(input: OrderCaptureInput!): OrderCapturePayload
    orderClose(input: OrderCloseInput!): OrderClosePayload
    orderEditAddCustomItem(id: ID!, title: String!, locationId: ID, price: MoneyInput!, quantity: Int!, taxable: Boolean, requiresShipping: Boolean): OrderEditAddCustomItemPayload
    orderEditAddLineItemDiscount(id: ID!, lineItemId: ID!, discount: OrderEditAppliedDiscountInput!): OrderEditAddLineItemDiscountPayload
    orderEditAddVariant(id: ID!, variantId: ID!, locationId: ID, quantity: Int!, allowDuplicates: Boolean): OrderEditAddVariantPayload
    orderEditBegin(id: ID!): OrderEditBeginPayload
    orderEditCommit(id: ID!, notifyCustomer: Boolean, staffNote: String): OrderEditCommitPayload
    orderEditRemoveLineItemDiscount(id: ID!, discountApplicationId: ID!): OrderEditRemoveLineItemDiscountPayload
    orderEditSetQuantity(id: ID!, lineItemId: ID!, quantity: Int!, restock: Boolean, locationId: ID): OrderEditSetQuantityPayload
    orderMarkAsPaid(input: OrderMarkAsPaidInput!): OrderMarkAsPaidPayload
    orderOpen(input: OrderOpenInput!): OrderOpenPayload
    orderUpdate(input: OrderInput!): OrderUpdatePayload
    paymentSessionReject(id: ID!, reason: PaymentSessionRejectionReasonInput!): PaymentSessionRejectPayload
    paymentSessionResolve(id: ID!, authorizationExpiresAt: DateTime): PaymentSessionResolvePayload
    paymentsAppConfigure(externalHandle: String, ready: Boolean!): PaymentsAppConfigurePayload
    priceListCreate(input: PriceListCreateInput!): PriceListCreatePayload
    priceListDelete(id: ID!): PriceListDeletePayload
    priceListFixedPricesAdd(priceListId: ID!, prices: [PriceListPriceInput!]!): PriceListFixedPricesAddPayload
    priceListFixedPricesDelete(priceListId: ID!, variantIds: [ID!]!): PriceListFixedPricesDeletePayload
    priceListUpdate(id: ID!, input: PriceListUpdateInput!): PriceListUpdatePayload
    priceRuleActivate(id: ID!): PriceRuleActivatePayload
    priceRuleCreate(priceRule: PriceRuleInput!, priceRuleDiscountCode: PriceRuleDiscountCodeInput): PriceRuleCreatePayload
    priceRuleDeactivate(id: ID!): PriceRuleDeactivatePayload
    priceRuleDelete(id: ID!): PriceRuleDeletePayload
    priceRuleDiscountCodeCreate(priceRuleId: ID!, code: String!): PriceRuleDiscountCodeCreatePayload
    priceRuleDiscountCodeUpdate(priceRuleId: ID!, code: String!): PriceRuleDiscountCodeUpdatePayload
    priceRuleUpdate(id: ID!, priceRule: PriceRuleInput!, priceRuleDiscountCode: PriceRuleDiscountCodeInput): PriceRuleUpdatePayload
    privateMetafieldDelete(input: PrivateMetafieldDeleteInput!): PrivateMetafieldDeletePayload
    privateMetafieldUpsert(input: PrivateMetafieldInput!): PrivateMetafieldUpsertPayload
    productAppendImages(input: ProductAppendImagesInput!): ProductAppendImagesPayload
    productChangeStatus(productId: ID!, status: ProductStatus!): ProductChangeStatusPayload
    productCreate(input: ProductInput!, media: [CreateMediaInput!]): ProductCreatePayload
    productCreateMedia(productId: ID!, media: [CreateMediaInput!]!): ProductCreateMediaPayload
    productDelete(input: ProductDeleteInput!): ProductDeletePayload
    productDeleteImages(id: ID!, imageIds: [ID!]!): ProductDeleteImagesPayload
    productDeleteMedia(productId: ID!, mediaIds: [ID!]!): ProductDeleteMediaPayload
    productDuplicate(productId: ID!, newTitle: String!, newStatus: ProductStatus, includeImages: Boolean = false): ProductDuplicatePayload
    productImageUpdate(productId: ID!, image: ImageInput!): ProductImageUpdatePayload
    productJoinSellingPlanGroups(id: ID!, sellingPlanGroupIds: [ID!]!): ProductJoinSellingPlanGroupsPayload
    productLeaveSellingPlanGroups(id: ID!, sellingPlanGroupIds: [ID!]!): ProductLeaveSellingPlanGroupsPayload
    productPublish(input: ProductPublishInput!): ProductPublishPayload @deprecated(reason: "Use `publishablePublish` instead")
    productReorderImages(id: ID!, moves: [MoveInput!]!): ProductReorderImagesPayload
    productReorderMedia(id: ID!, moves: [MoveInput!]!): ProductReorderMediaPayload
    productUnpublish(input: ProductUnpublishInput!): ProductUnpublishPayload @deprecated(reason: "Use `publishableUnpublish` instead")
    productUpdate(input: ProductInput!): ProductUpdatePayload
    productUpdateMedia(productId: ID!, media: [UpdateMediaInput!]!): ProductUpdateMediaPayload
    productVariantAppendMedia(productId: ID!, variantMedia: [ProductVariantAppendMediaInput!]!): ProductVariantAppendMediaPayload
    productVariantCreate(input: ProductVariantInput!): ProductVariantCreatePayload
    productVariantDelete(id: ID!): ProductVariantDeletePayload
    productVariantDetachMedia(productId: ID!, variantMedia: [ProductVariantDetachMediaInput!]!): ProductVariantDetachMediaPayload
    productVariantJoinSellingPlanGroups(id: ID!, sellingPlanGroupIds: [ID!]!): ProductVariantJoinSellingPlanGroupsPayload
    productVariantLeaveSellingPlanGroups(id: ID!, sellingPlanGroupIds: [ID!]!): ProductVariantLeaveSellingPlanGroupsPayload
    productVariantUpdate(input: ProductVariantInput!): ProductVariantUpdatePayload
    productVariantsBulkCreate(variants: [ProductVariantsBulkInput!]!, productId: ID!): ProductVariantsBulkCreatePayload
    productVariantsBulkDelete(variantsIds: [ID!]!, productId: ID!): ProductVariantsBulkDeletePayload
    productVariantsBulkReorder(productId: ID!, positions: [ProductVariantPositionInput!]!): ProductVariantsBulkReorderPayload
    productVariantsBulkUpdate(variants: [ProductVariantsBulkInput!]!, productId: ID!): ProductVariantsBulkUpdatePayload
    pubSubWebhookSubscriptionCreate(topic: WebhookSubscriptionTopic!, webhookSubscription: PubSubWebhookSubscriptionInput!): PubSubWebhookSubscriptionCreatePayload
    pubSubWebhookSubscriptionUpdate(id: ID!, webhookSubscription: PubSubWebhookSubscriptionInput): PubSubWebhookSubscriptionUpdatePayload
    publishablePublish(id: ID!, input: [PublicationInput!]!): PublishablePublishPayload
    publishablePublishToCurrentChannel(id: ID!): PublishablePublishToCurrentChannelPayload
    publishableUnpublish(id: ID!, input: [PublicationInput!]!): PublishableUnpublishPayload
    publishableUnpublishToCurrentChannel(id: ID!): PublishableUnpublishToCurrentChannelPayload
    refundCreate(input: RefundInput!): RefundCreatePayload
    refundSessionReject(id: ID!, reason: RefundSessionRejectionReasonInput!): RefundSessionRejectPayload
    refundSessionResolve(id: ID!): RefundSessionResolvePayload
    savedSearchCreate(input: SavedSearchCreateInput!): SavedSearchCreatePayload
    savedSearchDelete(input: SavedSearchDeleteInput!): SavedSearchDeletePayload
    savedSearchUpdate(input: SavedSearchUpdateInput!): SavedSearchUpdatePayload
    scriptTagCreate(input: ScriptTagInput!): ScriptTagCreatePayload
    scriptTagDelete(id: ID!): ScriptTagDeletePayload
    scriptTagUpdate(id: ID!, input: ScriptTagInput!): ScriptTagUpdatePayload
    sellingPlanGroupAddProductVariants(id: ID!, productVariantIds: [ID!]!): SellingPlanGroupAddProductVariantsPayload
    sellingPlanGroupAddProducts(id: ID!, productIds: [ID!]!): SellingPlanGroupAddProductsPayload
    sellingPlanGroupCreate(input: SellingPlanGroupInput!, resources: SellingPlanGroupResourceInput): SellingPlanGroupCreatePayload
    sellingPlanGroupDelete(id: ID!): SellingPlanGroupDeletePayload
    sellingPlanGroupRemoveProductVariants(id: ID!, productVariantIds: [ID!]!): SellingPlanGroupRemoveProductVariantsPayload
    sellingPlanGroupRemoveProducts(id: ID!, productIds: [ID!]!): SellingPlanGroupRemoveProductsPayload
    sellingPlanGroupUpdate(id: ID!, input: SellingPlanGroupInput): SellingPlanGroupUpdatePayload
    shippingPackageDelete(id: ID!): ShippingPackageDeletePayload
    shippingPackageMakeDefault(id: ID!): ShippingPackageMakeDefaultPayload
    shippingPackageUpdate(id: ID!): ShippingPackageUpdatePayload
    shopLocaleDisable(locale: String!): ShopLocaleDisablePayload
    shopLocaleEnable(locale: String!): ShopLocaleEnablePayload
    shopLocaleUpdate(locale: String!, shopLocale: ShopLocaleInput!): ShopLocaleUpdatePayload
    shopPolicyUpdate(shopPolicy: ShopPolicyInput!): ShopPolicyUpdatePayload
    stagedUploadTargetGenerate(input: StagedUploadTargetGenerateInput!): StagedUploadTargetGeneratePayload @deprecated(reason: "Use `stagedUploadsCreate` instead")
    stagedUploadTargetsGenerate(input: [StageImageInput!]!): StagedUploadTargetsGeneratePayload @deprecated(reason: "Use `stagedUploadsCreate` instead")
    stagedUploadsCreate(input: [StagedUploadInput!]!): StagedUploadsCreatePayload
    storefrontAccessTokenCreate(input: StorefrontAccessTokenInput!): StorefrontAccessTokenCreatePayload
    storefrontAccessTokenDelete(input: StorefrontAccessTokenDeleteInput!): StorefrontAccessTokenDeletePayload
    subscriptionBillingAttemptCreate(subscriptionContractId: ID!, subscriptionBillingAttemptInput: SubscriptionBillingAttemptInput!): SubscriptionBillingAttemptCreatePayload
    subscriptionContractCreate(input: SubscriptionContractCreateInput!): SubscriptionContractCreatePayload
    subscriptionContractSetNextBillingDate(contractId: ID!, date: DateTime!): SubscriptionContractSetNextBillingDatePayload
    subscriptionContractUpdate(contractId: ID!): SubscriptionContractUpdatePayload
    subscriptionDraftCommit(draftId: ID!): SubscriptionDraftCommitPayload
    subscriptionDraftDiscountAdd(draftId: ID!, input: SubscriptionManualDiscountInput!): SubscriptionDraftDiscountAddPayload
    subscriptionDraftDiscountCodeApply(draftId: ID!, redeemCode: String!): SubscriptionDraftDiscountCodeApplyPayload
    subscriptionDraftDiscountRemove(draftId: ID!, discountId: ID!): SubscriptionDraftDiscountRemovePayload
    subscriptionDraftDiscountUpdate(draftId: ID!, discountId: ID!, input: SubscriptionManualDiscountInput!): SubscriptionDraftDiscountUpdatePayload
    subscriptionDraftFreeShippingDiscountAdd(draftId: ID!, input: SubscriptionFreeShippingDiscountInput!): SubscriptionDraftFreeShippingDiscountAddPayload
    subscriptionDraftFreeShippingDiscountUpdate(draftId: ID!, discountId: ID!, input: SubscriptionFreeShippingDiscountInput!): SubscriptionDraftFreeShippingDiscountUpdatePayload
    subscriptionDraftLineAdd(draftId: ID!, input: SubscriptionLineInput!): SubscriptionDraftLineAddPayload
    subscriptionDraftLineRemove(draftId: ID!, lineId: ID!): SubscriptionDraftLineRemovePayload
    subscriptionDraftLineUpdate(draftId: ID!, lineId: ID!, input: SubscriptionLineUpdateInput!): SubscriptionDraftLineUpdatePayload
    subscriptionDraftUpdate(draftId: ID!, input: SubscriptionDraftInput!): SubscriptionDraftUpdatePayload
    tagsAdd(id: ID!, tags: [String!]!): TagsAddPayload
    tagsRemove(id: ID!, tags: [String!]!): TagsRemovePayload
    translationsRegister(resourceId: ID!, translations: [TranslationInput!]!): TranslationsRegisterPayload
    translationsRemove(resourceId: ID!, translationKeys: [String!]!, locales: [String!]!): TranslationsRemovePayload
    urlRedirectBulkDeleteAll: UrlRedirectBulkDeleteAllPayload
    urlRedirectBulkDeleteByIds(ids: [ID!]!): UrlRedirectBulkDeleteByIdsPayload
    urlRedirectBulkDeleteBySavedSearch(savedSearchId: ID!): UrlRedirectBulkDeleteBySavedSearchPayload
    urlRedirectBulkDeleteBySearch(search: String!): UrlRedirectBulkDeleteBySearchPayload
    urlRedirectCreate(urlRedirect: UrlRedirectInput!): UrlRedirectCreatePayload
    urlRedirectDelete(id: ID!): UrlRedirectDeletePayload
    urlRedirectImportCreate(url: URL!): UrlRedirectImportCreatePayload
    urlRedirectImportSubmit(id: ID!): UrlRedirectImportSubmitPayload
    urlRedirectUpdate(id: ID, urlRedirect: UrlRedirectInput!): UrlRedirectUpdatePayload
    voidSessionReject(id: ID!, reason: VoidSessionRejectionReasonInput!): VoidSessionRejectPayload
    voidSessionResolve(id: ID!): VoidSessionResolvePayload
    webhookSubscriptionCreate(topic: WebhookSubscriptionTopic!, webhookSubscription: WebhookSubscriptionInput!): WebhookSubscriptionCreatePayload
    webhookSubscriptionDelete(id: ID!): WebhookSubscriptionDeletePayload
    webhookSubscriptionUpdate(id: ID!, webhookSubscription: WebhookSubscriptionInput!): WebhookSubscriptionUpdatePayload
}

type MutationsStagedUploadTargetGenerateUploadParameter {
    name: String!
    value: String!
}

interface Navigable {
    defaultCursor: String!
}

type NavigationItem {
    id: String!
    title: String!
    url: URL!
}

interface Node {
    id: ID!
}

type OnlineStoreArticle implements Node & Navigable & HasPublishedTranslations {
    defaultCursor: String!
    id: ID!
    translations(locale: String!): [PublishedTranslation!]!
}

type OnlineStoreBlog implements Node & HasPublishedTranslations {
    id: ID!
    translations(locale: String!): [PublishedTranslation!]!
}

type OnlineStorePage implements Node & Navigable & HasPublishedTranslations {
    defaultCursor: String!
    id: ID!
    translations(locale: String!): [PublishedTranslation!]!
}

interface OnlineStorePreviewable {
    onlineStorePreviewUrl: URL
}

type Order implements Node & CommentEventSubject & HasMetafields & LegacyInteroperability & HasEvents & HasLocalizationExtensions {
    agreements(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): SalesAgreementConnection!
    alerts: [ResourceAlert!]!
    billingAddress: MailingAddress
    billingAddressMatchesShippingAddress: Boolean!
    canMarkAsPaid: Boolean!
    canNotifyCustomer: Boolean!
    cancelReason: OrderCancelReason
    cancelledAt: DateTime
    capturable: Boolean!
    cartDiscountAmount: Money @deprecated(reason: "Use `cartDiscountAmountSet` instead")
    cartDiscountAmountSet: MoneyBag
    channel: Channel @deprecated(reason: "Use `publication` instead")
    clientIp: String
    closed: Boolean!
    closedAt: DateTime
    confirmed: Boolean!
    createdAt: DateTime!
    currencyCode: CurrencyCode!
    currentCartDiscountAmountSet: MoneyBag!
    currentSubtotalLineItemsQuantity: Int!
    currentSubtotalPriceSet: MoneyBag!
    currentTaxLines: [TaxLine!]!
    currentTotalDiscountsSet: MoneyBag!
    currentTotalDutiesSet: MoneyBag
    currentTotalPriceSet: MoneyBag!
    currentTotalTaxSet: MoneyBag!
    currentTotalWeight: UnsignedInt64!
    customAttributes: [Attribute!]!
    customer: Customer
    customerAcceptsMarketing: Boolean!
    customerJourney: CustomerJourney @deprecated(reason: "Use `customerJourneySummary` instead")
    customerJourneySummary: CustomerJourneySummary
    customerLocale: String
    discountApplications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): DiscountApplicationConnection!
    discountCode: String
    displayAddress: MailingAddress
    displayFinancialStatus: OrderDisplayFinancialStatus
    displayFulfillmentStatus: OrderDisplayFulfillmentStatus!
    disputes: [OrderDisputeSummary!]!
    draftFulfillments: [DraftFulfillment!]! @deprecated(reason: "Use `fulfillmentOrders` instead")
    edited: Boolean!
    email: String
    estimatedTaxes: Boolean!
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
    fulfillable: Boolean!
    fulfillmentOrders(displayable: Boolean = false, first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): FulfillmentOrderConnection!
    fulfillments(first: Int): [Fulfillment!]!
    fullyPaid: Boolean!
    hasTimelineComment: Boolean!
    id: ID!
    landingPageDisplayText: String @deprecated(reason: "Use `customerJourneySummary.lastVisit.landingPageHtml` instead")
    landingPageUrl: URL @deprecated(reason: "Use `customerJourneySummary.lastVisit.landingPage` instead")
    legacyResourceId: UnsignedInt64!
    lineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LineItemConnection!
    lineItemsMutable(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LineItemMutableConnection! @deprecated(reason: "Use `lineItems` instead")
    localizationExtensions(countryCodes: [CountryCode!], purposes: [LocalizationExtensionPurpose!], first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LocalizationExtensionConnection!
    location: String @deprecated(reason: "Use `physicalLocation` instead")
    merchantEditable: Boolean!
    merchantEditableErrors: [String!]!
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    name: String!
    netPayment: Money! @deprecated(reason: "Use `netPaymentSet` instead")
    netPaymentSet: MoneyBag!
    nonFulfillableLineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LineItemConnection!
    note: String
    originalTotalDutiesSet: MoneyBag
    originalTotalPriceSet: MoneyBag!
    paymentCollectionDetails: OrderPaymentCollectionDetails!
    paymentGatewayNames: [String!]!
    phone: String
    physicalLocation: Location
    presentmentCurrencyCode: CurrencyCode!
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    processedAt: DateTime!
    publication: Publication
    referralCode: String @deprecated(reason: "Use `customerJourneySummary.lastVisit.referralCode` instead")
    referrerDisplayText: String @deprecated(reason: "Use `customerJourneySummary.lastVisit.referralInfoHtml` instead")
    referrerUrl: URL @deprecated(reason: "Use `customerJourneySummary.lastVisit.referrerUrl` instead")
    refundDiscrepancySet: MoneyBag!
    refundable: Boolean!
    refunds(first: Int): [Refund!]!
    requiresShipping: Boolean!
    restockable: Boolean!
    riskLevel: OrderRiskLevel!
    risks(first: Int): [OrderRisk!]!
    shippingAddress: MailingAddress
    shippingLine: ShippingLine
    shippingLines(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ShippingLineConnection!
    subtotalLineItemsQuantity: Int!
    subtotalPrice: Money @deprecated(reason: "Use `subtotalPriceSet` instead")
    subtotalPriceSet: MoneyBag
    suggestedRefund(shippingAmount: Money, refundShipping: Boolean, refundLineItems: [RefundLineItemInput!], refundDuties: [RefundDutyInput!], suggestFullRefund: Boolean = false): SuggestedRefund
    tags: [String!]!
    taxLines: [TaxLine!]!
    taxesIncluded: Boolean!
    test: Boolean!
    totalCapturable: Money! @deprecated(reason: "Use `totalCapturableSet` instead")
    totalCapturableSet: MoneyBag!
    totalDiscounts: Money @deprecated(reason: "Use `totalDiscountsSet` instead")
    totalDiscountsSet: MoneyBag
    totalOutstandingSet: MoneyBag!
    totalPrice: Money! @deprecated(reason: "Use `totalPriceSet` instead")
    totalPriceSet: MoneyBag!
    totalReceived: Money! @deprecated(reason: "Use `totalReceivedSet` instead")
    totalReceivedSet: MoneyBag!
    totalRefunded: Money! @deprecated(reason: "Use `totalRefundedSet` instead")
    totalRefundedSet: MoneyBag!
    totalRefundedShippingSet: MoneyBag!
    totalShippingPrice: Money! @deprecated(reason: "Use `totalShippingPriceSet` instead")
    totalShippingPriceSet: MoneyBag!
    totalTax: Money @deprecated(reason: "Use `totalTaxSet` instead")
    totalTaxSet: MoneyBag
    totalTipReceived: MoneyV2! @deprecated(reason: "Use `totalTipReceivedSet` instead")
    totalTipReceivedSet: MoneyBag!
    totalWeight: UnsignedInt64
    transactions(first: Int, capturable: Boolean, manuallyResolvable: Boolean): [OrderTransaction!]!
    unpaid: Boolean!
    updatedAt: DateTime!
}

enum OrderActionType {
    ORDER
    ORDER_EDIT
    REFUND
    UNKNOWN
}

type OrderAgreement implements SalesAgreement {
    app: App
    happenedAt: DateTime!
    id: ID!
    order: Order!
    reason: OrderActionType!
    sales(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SaleConnection!
}

enum OrderCancelReason {
    CUSTOMER
    FRAUD
    INVENTORY
    DECLINED
    OTHER
}

input OrderCaptureInput {
    id: ID!
    parentTransactionId: ID!
    amount: Money!
    currency: CurrencyCode
}

type OrderCapturePayload {
    transaction: OrderTransaction
    userErrors: [UserError!]!
}

input OrderCloseInput {
    id: ID!
}

type OrderClosePayload {
    order: Order
    userErrors: [UserError!]!
}

type OrderConnection {
    edges: [OrderEdge!]!
    pageInfo: PageInfo!
}

enum OrderDisplayFinancialStatus {
    PENDING
    AUTHORIZED
    PARTIALLY_PAID
    PARTIALLY_REFUNDED
    VOIDED
    PAID
    REFUNDED
    EXPIRED
}

enum OrderDisplayFulfillmentStatus {
    UNFULFILLED
    PARTIALLY_FULFILLED
    FULFILLED
    RESTOCKED
    PENDING_FULFILLMENT
    OPEN
    IN_PROGRESS
    ON_HOLD
    SCHEDULED
}

type OrderDisputeSummary implements Node {
    id: ID!
    initiatedAs: DisputeType!
    status: DisputeStatus!
}

type OrderEdge {
    cursor: String!
    node: Order!
}

type OrderEditAddCustomItemPayload {
    calculatedLineItem: CalculatedLineItem
    calculatedOrder: CalculatedOrder
    userErrors: [UserError!]!
}

type OrderEditAddLineItemDiscountPayload {
    addedDiscountStagedChange: OrderStagedChangeAddLineItemDiscount
    calculatedLineItem: CalculatedLineItem
    calculatedOrder: CalculatedOrder
    userErrors: [UserError!]!
}

type OrderEditAddVariantPayload {
    calculatedLineItem: CalculatedLineItem
    calculatedOrder: CalculatedOrder
    userErrors: [UserError!]!
}

type OrderEditAgreement implements SalesAgreement {
    app: App
    happenedAt: DateTime!
    id: ID!
    reason: OrderActionType!
    sales(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SaleConnection!
}

input OrderEditAppliedDiscountInput {
    description: String
    fixedValue: MoneyInput
    percentValue: Float
}

type OrderEditBeginPayload {
    calculatedOrder: CalculatedOrder
    userErrors: [UserError!]!
}

type OrderEditCommitPayload {
    order: Order
    userErrors: [UserError!]!
}

type OrderEditRemoveLineItemDiscountPayload {
    calculatedLineItem: CalculatedLineItem
    calculatedOrder: CalculatedOrder
    userErrors: [UserError!]!
}

type OrderEditSetQuantityPayload {
    calculatedLineItem: CalculatedLineItem
    calculatedOrder: CalculatedOrder
    userErrors: [UserError!]!
}

input OrderInput {
    email: String
    id: ID!
    note: String
    tags: [String!]
    shippingAddress: MailingAddressInput
    customAttributes: [AttributeInput!]
    metafields: [MetafieldInput!]
    localizationExtensions: [LocalizationExtensionInput!]
}

input OrderMarkAsPaidInput {
    id: ID!
}

type OrderMarkAsPaidPayload {
    order: Order
    userErrors: [UserError!]!
}

input OrderOpenInput {
    id: ID!
}

type OrderOpenPayload {
    order: Order
    userErrors: [UserError!]!
}

type OrderPaymentCollectionDetails {
    additionalPaymentCollectionUrl: URL
}

type OrderRisk {
    display: Boolean!
    level: OrderRiskLevel
    message: String
}

enum OrderRiskLevel {
    LOW
    MEDIUM
    HIGH
}

enum OrderSortKeys {
    CREATED_AT
    CUSTOMER_NAME
    FINANCIAL_STATUS
    FULFILLMENT_STATUS
    ORDER_NUMBER
    PROCESSED_AT
    TOTAL_PRICE
    UPDATED_AT
    ID
    RELEVANCE
}

union OrderStagedChange = OrderStagedChangeAddCustomItem | OrderStagedChangeAddLineItemDiscount | OrderStagedChangeAddShippingLine | OrderStagedChangeAddVariant | OrderStagedChangeDecrementItem | OrderStagedChangeIncrementItem

type OrderStagedChangeAddCustomItem {
    originalUnitPrice: MoneyV2!
    quantity: Int!
    title: String!
}

type OrderStagedChangeAddLineItemDiscount {
    description: String!
    id: ID!
    value: PricingValue!
}

type OrderStagedChangeAddShippingLine {
    phone: String
    presentmentTitle: String
    price: MoneyV2!
    title: String
}

type OrderStagedChangeAddVariant {
    quantity: Int!
    variant: ProductVariant!
}

type OrderStagedChangeConnection {
    edges: [OrderStagedChangeEdge!]!
    pageInfo: PageInfo!
}

type OrderStagedChangeDecrementItem {
    delta: Int!
    lineItem: LineItem!
    restock: Boolean!
}

type OrderStagedChangeEdge {
    cursor: String!
    node: OrderStagedChange!
}

type OrderStagedChangeIncrementItem {
    delta: Int!
    lineItem: LineItem!
}

type OrderTransaction implements Node {
    accountNumber: String
    amount: Money! @deprecated(reason: "Use `amountSet` instead")
    amountSet: MoneyBag!
    amountV2: MoneyV2! @deprecated(reason: "Use `amountSet` instead")
    authorizationCode: String
    authorizationExpiresAt: DateTime
    createdAt: DateTime!
    errorCode: OrderTransactionErrorCode
    fees: [TransactionFee!]!
    formattedGateway: String
    gateway: String
    id: ID!
    kind: OrderTransactionKind!
    manuallyCapturable: Boolean!
    maximumRefundable: Money @deprecated(reason: "Use `maximumRefundableV2` instead")
    maximumRefundableV2: MoneyV2
    order: Order
    parentTransaction: OrderTransaction
    paymentIcon(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    paymentMethod: PaymentMethods @deprecated(reason: "Use `paymentIcon` instead")
    processedAt: DateTime
    receipt: String @deprecated(reason: "Use `receiptJson` instead")
    settlementCurrency: CurrencyCode
    settlementCurrencyRate: Decimal
    shopifyPaymentsSet: ShopifyPaymentsTransactionSet
    status: OrderTransactionStatus!
    test: Boolean!
    totalUnsettled: Money @deprecated(reason: "Use `totalUnsettledSet` instead")
    totalUnsettledSet: MoneyBag
    totalUnsettledV2: MoneyV2 @deprecated(reason: "Use `totalUnsettledSet` instead")
}

type OrderTransactionConnection {
    edges: [OrderTransactionEdge!]!
    pageInfo: PageInfo!
}

type OrderTransactionEdge {
    cursor: String!
    node: OrderTransaction!
}

enum OrderTransactionErrorCode {
    INCORRECT_NUMBER
    INVALID_NUMBER
    INVALID_EXPIRY_DATE
    INVALID_CVC
    EXPIRED_CARD
    INCORRECT_CVC
    INCORRECT_ZIP
    INCORRECT_ADDRESS
    INCORRECT_PIN
    CARD_DECLINED
    PROCESSING_ERROR
    CALL_ISSUER
    PICK_UP_CARD
    CONFIG_ERROR
    TEST_MODE_LIVE_CARD
    UNSUPPORTED_FEATURE
    GENERIC_ERROR
    INVALID_COUNTRY
    INVALID_AMOUNT
    PAYMENT_METHOD_UNAVAILABLE
    AMAZON_PAYMENTS_INVALID_PAYMENT_METHOD
    AMAZON_PAYMENTS_MAX_AMOUNT_CHARGED
    AMAZON_PAYMENTS_MAX_AMOUNT_REFUNDED
    AMAZON_PAYMENTS_MAX_AUTHORIZATIONS_CAPTURED
    AMAZON_PAYMENTS_MAX_REFUNDS_PROCESSED
    AMAZON_PAYMENTS_ORDER_REFERENCE_CANCELED
    AMAZON_PAYMENTS_STALE
}

input OrderTransactionInput {
    amount: Money!
    gateway: String!
    kind: OrderTransactionKind!
    orderId: ID!
    parentId: ID
}

enum OrderTransactionKind {
    SALE
    CAPTURE
    AUTHORIZATION
    VOID
    REFUND
    CHANGE
    EMV_AUTHORIZATION
    SUGGESTED_REFUND
}

enum OrderTransactionStatus {
    SUCCESS
    FAILURE
    PENDING
    ERROR
    AWAITING_RESPONSE
    UNKNOWN
}

type OrderUpdatePayload {
    order: Order
    userErrors: [UserError!]!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}

enum PaymentMethods {
    VISA
    MASTERCARD
    DISCOVER
    AMERICAN_EXPRESS
    DINERS_CLUB
    JCB
    DANKORT
    MAESTRO
    FORBRUGSFORENINGEN
    PAYPAL
    BOGUS
    BITCOIN
    LITECOIN
    DOGECOIN
}

type PaymentsAppConfiguration {
    externalHandle: String
    ready: Boolean!
}

type PaymentsAppConfigurePayload {
    paymentsAppConfiguration: PaymentsAppConfiguration
    userErrors: [UserError!]!
}

type PaymentSession {
    authorizationExpiresAt: DateTime
    id: ID!
    nextAction: PaymentSessionNextAction
    status: PaymentSessionStatus!
}

type PaymentSessionActionsRedirect {
    redirectUrl: URL!
}

type PaymentSessionNextAction {
    action: PaymentSessionNextActionAction!
    context: PaymentSessionNextActionContext!
}

enum PaymentSessionNextActionAction {
    REDIRECT
}

union PaymentSessionNextActionContext = PaymentSessionActionsRedirect

input PaymentSessionRejectionReasonInput {
    code: PaymentSessionStatusReasonRejectionCode!
    merchantMessage: String
}

type PaymentSessionRejectPayload {
    paymentSession: PaymentSession
    userErrors: [UserError!]!
}

type PaymentSessionResolvePayload {
    paymentSession: PaymentSession
    userErrors: [UserError!]!
}

type PaymentSessionStatus {
    code: PaymentSessionStatusCode!
    reason: PaymentSessionStatusReason
}

enum PaymentSessionStatusCode {
    REJECTED
    RESOLVED
}

type PaymentSessionStatusReason {
    code: PaymentSessionStatusReasonRejectionCode!
    merchantMessage: String
}

enum PaymentSessionStatusReasonRejectionCode {
    RISKY
    PROCESSING_ERROR
}

type PaymentSettings {
    supportedDigitalWallets: [DigitalWallet!]!
}

enum PaypalExpressSubscriptionsGatewayStatus {
    ENABLED
    DISABLED
    PENDING
}

type PriceList implements Node {
    contextRule: PriceListContextRule
    currency: CurrencyCode!
    id: ID!
    name: String!
    parent: PriceListParent
    prices(originType: PriceListPriceOriginType, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PriceListPriceConnection!
}

type PriceListAdjustment {
    type: PriceListAdjustmentType!
    value: Float!
}

input PriceListAdjustmentInput {
    value: Float!
    type: PriceListAdjustmentType!
}

enum PriceListAdjustmentType {
    PERCENTAGE_DECREASE
    PERCENTAGE_INCREASE
}

type PriceListConnection {
    edges: [PriceListEdge!]!
    pageInfo: PageInfo!
}

input PriceListContext {
    country: CountryCode
}

type PriceListContextRule {
    countries: [CountryCode!]!
}

input PriceListContextRuleInput {
    countries: [CountryCode!]
}

input PriceListCreateInput {
    name: String!
    currency: CurrencyCode!
    parent: PriceListParentCreateInput!
    contextRule: PriceListContextRuleInput
}

type PriceListCreatePayload {
    priceList: PriceList
    userErrors: [PriceListUserError!]!
}

type PriceListDeletePayload {
    deletedId: ID
    userErrors: [PriceListUserError!]!
}

type PriceListEdge {
    cursor: String!
    node: PriceList!
}

type PriceListFixedPricesAddPayload {
    prices: [PriceListPrice!]
    userErrors: [PriceListPriceUserError!]!
}

type PriceListFixedPricesDeletePayload {
    deletedFixedPriceVariantIds: [ID!]
    userErrors: [PriceListPriceUserError!]!
}

type PriceListParent {
    adjustment: PriceListAdjustment!
}

input PriceListParentCreateInput {
    adjustment: PriceListAdjustmentInput!
}

input PriceListParentUpdateInput {
    adjustment: PriceListAdjustmentInput!
}

type PriceListPrice {
    compareAtPrice: MoneyV2
    originType: PriceListPriceOriginType!
    price: MoneyV2!
    variant: ProductVariant!
}

type PriceListPriceConnection {
    edges: [PriceListPriceEdge!]!
    pageInfo: PageInfo!
}

type PriceListPriceEdge {
    cursor: String!
    node: PriceListPrice!
}

input PriceListPriceInput {
    variantId: ID!
    price: MoneyInput!
    compareAtPrice: MoneyInput
}

enum PriceListPriceOriginType {
    FIXED
    RELATIVE
}

type PriceListPriceUserError implements DisplayableError {
    code: PriceListPriceUserErrorCode
    field: [String!]
    message: String!
}

enum PriceListPriceUserErrorCode {
    BLANK
    PRICE_LIST_NOT_FOUND
    PRICE_LIST_CURRENCY_MISMATCH
    VARIANT_NOT_FOUND
    PRICE_NOT_FIXED
}

enum PriceListSortKeys {
    NAME
    ID
    RELEVANCE
}

input PriceListUpdateInput {
    name: String
    currency: CurrencyCode
    contextRule: PriceListContextRuleInput
    parent: PriceListParentUpdateInput
}

type PriceListUpdatePayload {
    priceList: PriceList
    userErrors: [PriceListUserError!]!
}

type PriceListUserError implements DisplayableError {
    code: PriceListUserErrorCode
    field: [String!]
    message: String!
}

enum PriceListUserErrorCode {
    TAKEN
    PRICE_LIST_NOT_FOUND
    CONTEXT_RULE_LIMIT_REACHED
    CONTEXT_RULE_COUNTRIES_LIMIT
    CURRENCY_COUNTRY_MISMATCH
    COUNTRY_CURRENCY_MISMATCH
    INVALID_ADJUSTMENT_VALUE
    CONTEXT_RULE_COUNTRY_TAKEN
}

type PriceRule implements Node & CommentEventSubject & LegacyInteroperability & HasEvents {
    allocationLimit: Int
    allocationMethod: PriceRuleAllocationMethod!
    app: App
    createdAt: DateTime!
    customerSelection: PriceRuleCustomerSelection!
    discountCodes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DiscountCodeSortKeys = ID, query: String, savedSearchId: ID): PriceRuleDiscountCodeConnection!
    discountCodesCount: Int!
    endsAt: DateTime
    entitlementToPrerequisiteQuantityRatio: PriceRuleEntitlementToPrerequisiteQuantityRatio @deprecated(reason: "Use `prerequisiteToEntitlementQuantityRatio` instead")
    events(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: EventSortKeys = ID, query: String): EventConnection!
    features: [PriceRuleFeature!]!
    hasTimelineComment: Boolean!
    id: ID!
    itemEntitlements: PriceRuleItemEntitlements!
    itemPrerequisites: PriceRuleLineItemPrerequisites!
    legacyResourceId: UnsignedInt64!
    oncePerCustomer: Boolean!
    prerequisiteQuantityRange: PriceRuleQuantityRange
    prerequisiteShippingPriceRange: PriceRuleMoneyRange
    prerequisiteSubtotalRange: PriceRuleMoneyRange
    prerequisiteToEntitlementQuantityRatio: PriceRulePrerequisiteToEntitlementQuantityRatio
    shareableUrls: [PriceRuleShareableUrl!]!
    shippingEntitlements: PriceRuleShippingLineEntitlements!
    startsAt: DateTime!
    status: PriceRuleStatus!
    summary: String
    target: PriceRuleTarget!
    title: String!
    totalSales: MoneyV2
    traits: [PriceRuleTrait!]! @deprecated(reason: "Use `features` instead")
    usageCount: Int!
    usageLimit: Int
    validityPeriod: PriceRuleValidityPeriod!
    value: PriceRuleValue! @deprecated(reason: "Use `valueV2` instead")
    valueV2: PricingValue!
}

type PriceRuleActivatePayload {
    priceRule: PriceRule
    priceRuleUserErrors: [PriceRuleUserError!]!
    userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead")
}

enum PriceRuleAllocationMethod {
    EACH
    ACROSS
}

type PriceRuleConnection {
    edges: [PriceRuleEdge!]!
    pageInfo: PageInfo!
}

type PriceRuleCreatePayload {
    priceRule: PriceRule
    priceRuleDiscountCode: PriceRuleDiscountCode
    priceRuleUserErrors: [PriceRuleUserError!]!
    userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead")
}

type PriceRuleCustomerSelection {
    customers(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CustomerSortKeys = ID, query: String, savedSearchId: ID): CustomerConnection!
    forAllCustomers: Boolean!
    savedSearches: [SavedSearch!]!
}

input PriceRuleCustomerSelectionInput {
    forAllCustomers: Boolean = false
    savedSearchIds: [ID!]
    customerIdsToAdd: [ID!]
    customerIdsToRemove: [ID!]
}

type PriceRuleDeactivatePayload {
    priceRule: PriceRule
    priceRuleUserErrors: [PriceRuleUserError!]!
    userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead")
}

type PriceRuleDeletePayload {
    deletedPriceRuleId: ID
    priceRuleUserErrors: [PriceRuleUserError!]!
    shop: Shop!
    userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead")
}

type PriceRuleDiscountCode implements Node {
    app: App
    code: String!
    id: ID!
    usageCount: Int!
}

type PriceRuleDiscountCodeConnection {
    edges: [PriceRuleDiscountCodeEdge!]!
    pageInfo: PageInfo!
}

type PriceRuleDiscountCodeCreatePayload {
    priceRule: PriceRule
    priceRuleDiscountCode: PriceRuleDiscountCode
    priceRuleUserErrors: [PriceRuleUserError!]!
    userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead")
}

type PriceRuleDiscountCodeEdge {
    cursor: String!
    node: PriceRuleDiscountCode!
}

input PriceRuleDiscountCodeInput {
    code: String
}

type PriceRuleDiscountCodeUpdatePayload {
    priceRule: PriceRule
    priceRuleDiscountCode: PriceRuleDiscountCode
    priceRuleUserErrors: [PriceRuleUserError!]!
    userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead")
}

type PriceRuleEdge {
    cursor: String!
    node: PriceRule!
}

type PriceRuleEntitlementToPrerequisiteQuantityRatio {
    entitlementQuantity: Int!
    prerequisiteQuantity: Int!
}

input PriceRuleEntitlementToPrerequisiteQuantityRatioInput {
    entitlementQuantity: Int
    prerequisiteQuantity: Int
}

enum PriceRuleErrorCode {
    BLANK
    EQUAL_TO
    GREATER_THAN
    GREATER_THAN_OR_EQUAL_TO
    INVALID
    LESS_THAN
    LESS_THAN_OR_EQUAL_TO
    TAKEN
    TOO_LONG
    TOO_SHORT
    INTERNAL_ERROR
    TOO_MANY_ARGUMENTS
    MISSING_ARGUMENT
    CUSTOMER_PREREQUISITE_DUPLICATE
    CANNOT_ENTITLE_COLLECTIONS_WITH_PRODUCTS_OR_VARIANTS
    ITEM_ENTITLEMENT_INVALID_TYPE
    ITEM_ENTITLEMENTS_DUPLICATE_COLLECTION
    ITEM_ENTITLEMENTS_DUPLICATE_PRODUCT
    ITEM_ENTITLEMENTS_DUPLICATE_VARIANT
    ITEM_ENTITLEMENTS_EXCEEDED_MAX_COLLECTION
    ITEM_ENTITLEMENTS_EXCEEDED_MAX_PRODUCT
    ITEM_ENTITLEMENTS_EXCEEDED_MAX_VARIANT
    ITEM_ENTITLEMENTS_INVALID_COLLECTION
    ITEM_ENTITLEMENTS_INVALID_PRODUCT
    ITEM_ENTITLEMENTS_INVALID_TARGET_TYPE_OR_SELECTION
    ITEM_ENTITLEMENTS_INVALID_VARIANT
    ITEM_ENTITLEMENTS_MISSING
    VARIANT_ALREADY_ENTITLED_THROUGH_PRODUCT
    CANNOT_PREREQUISITE_COLLECTION_WITH_PRODUCT_OR_VARIANTS
    ITEM_PREREQUISITES_DUPLICATE_COLLECTION
    ITEM_PREREQUISITES_DUPLICATE_PRODUCT
    ITEM_PREREQUISITES_DUPLICATE_VARIANT
    ITEM_PREREQUISITES_EXCEEDED_MAX
    ITEM_PREREQUISITES_INVALID_COLLECTION
    ITEM_PREREQUISITES_INVALID_PRODUCT
    ITEM_PREREQUISITES_INVALID_TYPE
    ITEM_PREREQUISITES_INVALID_VARIANT
    ITEM_PREREQUISITES_MISSING
    ITEM_PREREQUISITES_MUST_BE_EMPTY
    INVALID_TARGET_TYPE_PREREQUISITE_SHIPPING_PRICE_RANGE
    SHIPPING_ENTITLEMENTS_DUPLICATE_COUNTRY
    SHIPPING_ENTITLEMENTS_EXCEEDED_MAX
    SHIPPING_ENTITLEMENTS_INVALID_COUNTRY
    SHIPPING_ENTITLEMENTS_INVALID_TARGET_TYPE_OR_SELECTION
    SHIPPING_ENTITLEMENTS_MISSING
    SHIPPING_ENTITLEMENTS_UNSUPPORTED_DESTINATION_TYPE
    BOTH_CUSTOMER_AND_SAVED_SEARCH_PREREQUISITES_SELECTED
    CUSTOMER_PREREQUISITES_EXCEEDED_MAX
    CUSTOMER_PREREQUISITES_INVALID_SELECTION
    CUSTOMER_PREREQUISITES_MISSING
    CUSTOMER_SAVED_SEARCH_DUPLICATE
    CUSTOMER_SAVED_SEARCH_EXCEEDED_MAX
    CUSTOMER_SAVED_SEARCH_INVALID
    DISCOUNT_CODE_DUPLICATE
    BOGO_INVALID_TARGET_SELECTION
    BOGO_INVALID_TARGET_TYPE
    BOGO_INVALID_VALUE_TYPE
    PRICE_RULE_ALLOCATION_LIMIT_ON_NON_BOGO
    PRICE_RULE_ALLOCATION_LIMIT_IS_ZERO
    PRICE_RULE_EXCEEDED_MAX_DISCOUNT_CODE
    SHOP_EXCEEDED_MAX_PRICE_RULES
    END_DATE_BEFORE_START_DATE
    PRICE_RULE_PERCENTAGE_VALUE_OUTSIDE_RANGE
    PREREQUISITE_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT
    ALLOCATION_METHOD_MUST_BE_ACROSS_FOR_GIVEN_TARGET_SELECTION
    APPLIES_ON_NOTHING
    MULTIPLE_RECURRING_CYCLE_LIMIT_FOR_NON_SUBSCRIPTION_ITEMS
    EXCEEDED_MAX
}

enum PriceRuleFeature {
    BUY_ONE_GET_ONE
    BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT
    BULK
    SPECIFIC_CUSTOMERS
    QUANTITY_DISCOUNTS
}

type PriceRuleFixedAmountValue {
    amount: Money!
}

input PriceRuleInput {
    validityPeriod: PriceRuleValidityPeriodInput
    oncePerCustomer: Boolean = false
    customerSelection: PriceRuleCustomerSelectionInput
    usageLimit: Int
    title: String
    allocationLimit: Int
    allocationMethod: PriceRuleAllocationMethod
    value: PriceRuleValueInput
    target: PriceRuleTarget
    prerequisiteSubtotalRange: PriceRuleMoneyRangeInput
    prerequisiteQuantityRange: PriceRuleQuantityRangeInput
    prerequisiteShippingPriceRange: PriceRuleMoneyRangeInput
    itemEntitlements: PriceRuleItemEntitlementsInput
    itemPrerequisites: PriceRuleItemPrerequisitesInput
    shippingEntitlements: PriceRuleShippingEntitlementsInput
    entitlementToPrerequisiteQuantityRatio: PriceRuleEntitlementToPrerequisiteQuantityRatioInput
    prerequisiteToEntitlementQuantityRatio: PriceRulePrerequisiteToEntitlementQuantityRatioInput
}

type PriceRuleItemEntitlements {
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CollectionConnection!
    productVariants(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductVariantConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductConnection!
    targetAllLineItems: Boolean!
}

input PriceRuleItemEntitlementsInput {
    targetAllLineItems: Boolean = false
    productIds: [ID!]
    productVariantIds: [ID!]
    collectionIds: [ID!]
}

input PriceRuleItemPrerequisitesInput {
    productIds: [ID!]
    productVariantIds: [ID!]
    collectionIds: [ID!]
}

type PriceRuleLineItemPrerequisites {
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CollectionConnection!
    productVariants(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductVariantConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductConnection!
}

type PriceRuleMoneyRange {
    greaterThan: Money
    greaterThanOrEqualTo: Money
    lessThan: Money
    lessThanOrEqualTo: Money
}

input PriceRuleMoneyRangeInput {
    lessThan: Money
    lessThanOrEqualTo: Money
    greaterThan: Money
    greaterThanOrEqualTo: Money
}

type PriceRulePercentValue {
    percentage: Float!
}

type PriceRulePrerequisiteToEntitlementQuantityRatio {
    entitlementQuantity: Int!
    prerequisiteQuantity: Int!
}

input PriceRulePrerequisiteToEntitlementQuantityRatioInput {
    entitlementQuantity: Int
    prerequisiteQuantity: Int
}

type PriceRuleQuantityRange {
    greaterThan: Int
    greaterThanOrEqualTo: Int
    lessThan: Int
    lessThanOrEqualTo: Int
}

input PriceRuleQuantityRangeInput {
    lessThan: Int
    lessThanOrEqualTo: Int
    greaterThan: Int
    greaterThanOrEqualTo: Int
}

type PriceRuleShareableUrl {
    targetItemImage: Image
    targetType: PriceRuleShareableUrlTargetType!
    title: String!
    url: URL!
}

enum PriceRuleShareableUrlTargetType {
    HOME
    PRODUCT
    COLLECTION
}

input PriceRuleShippingEntitlementsInput {
    targetAllShippingLines: Boolean = false
    countryCodes: [CountryCode!]
    includeRestOfWorld: Boolean = false
}

type PriceRuleShippingLineEntitlements {
    countryCodes: [CountryCode!]!
    includeRestOfWorld: Boolean!
    targetAllShippingLines: Boolean!
}

enum PriceRuleSortKeys {
    STARTS_AT
    ENDS_AT
    TITLE
    CREATED_AT
    UPDATED_AT
    ID
    RELEVANCE
}

enum PriceRuleStatus {
    ACTIVE
    EXPIRED
    SCHEDULED
}

enum PriceRuleTarget {
    LINE_ITEM
    SHIPPING_LINE
}

enum PriceRuleTrait {
    BUY_ONE_GET_ONE
    BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT
    BULK
    SPECIFIC_CUSTOMERS
    QUANTITY_DISCOUNTS
}

type PriceRuleUpdatePayload {
    priceRule: PriceRule
    priceRuleDiscountCode: PriceRuleDiscountCode
    priceRuleUserErrors: [PriceRuleUserError!]!
    userErrors: [UserError!]! @deprecated(reason: "Use `priceRuleUserErrors` instead")
}

type PriceRuleUserError implements DisplayableError {
    code: PriceRuleErrorCode
    field: [String!]
    message: String!
}

type PriceRuleValidityPeriod {
    end: DateTime
    start: DateTime!
}

input PriceRuleValidityPeriodInput {
    start: DateTime!
    end: DateTime
}

union PriceRuleValue = PriceRuleFixedAmountValue | PriceRulePercentValue

input PriceRuleValueInput {
    percentageValue: Float
    fixedAmountValue: Money
}

type PricingPercentageValue {
    percentage: Float!
}

union PricingValue = MoneyV2 | PricingPercentageValue

type PrivateMetafield implements Node {
    createdAt: DateTime!
    id: ID!
    key: String!
    namespace: String!
    updatedAt: DateTime!
    value: String!
    valueType: PrivateMetafieldValueType!
}

type PrivateMetafieldConnection {
    edges: [PrivateMetafieldEdge!]!
    pageInfo: PageInfo!
}

input PrivateMetafieldDeleteInput {
    owner: ID
    namespace: String!
    key: String!
}

type PrivateMetafieldDeletePayload {
    deletedPrivateMetafieldId: ID
    userErrors: [UserError!]!
}

type PrivateMetafieldEdge {
    cursor: String!
    node: PrivateMetafield!
}

input PrivateMetafieldInput {
    owner: ID
    namespace: String!
    key: String!
    valueInput: PrivateMetafieldValueInput!
}

type PrivateMetafieldUpsertPayload {
    privateMetafield: PrivateMetafield
    userErrors: [UserError!]!
}

input PrivateMetafieldValueInput {
    value: String!
    valueType: PrivateMetafieldValueType!
}

enum PrivateMetafieldValueType {
    STRING
    INTEGER
    JSON_STRING
}

type Product implements Node & Navigable & HasMetafields & HasPublishedTranslations & Publishable & OnlineStorePreviewable & LegacyInteroperability {
    availablePublicationCount: Int!
    bodyHtml: String @deprecated(reason: "Use `descriptionHtml` instead")
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CollectionSortKeys = ID, query: String): CollectionConnection!
    createdAt: DateTime!
    defaultCursor: String!
    description(truncateAt: Int): String!
    descriptionHtml: HTML!
    descriptionPlainSummary: String! @deprecated(reason: "Use `description` instead")
    featuredImage: Image
    featuredMedia: Media
    feedback: ResourceFeedback
    giftCardTemplateSuffix: String
    handle: String!
    hasOnlyDefaultVariant: Boolean!
    hasOutOfStockVariants: Boolean!
    id: ID!
    images(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductImageSortKeys = POSITION, maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): ImageConnection!
    inCollection(id: ID!): Boolean!
    isGiftCard: Boolean!
    legacyResourceId: UnsignedInt64!
    media(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductMediaSortKeys = POSITION): MediaConnection!
    mediaCount: Int!
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    onlineStorePreviewUrl: URL
    onlineStoreUrl: URL
    options(first: Int): [ProductOption!]!
    priceRange: ProductPriceRange! @deprecated(reason: "Deprecated in API version 2020-10. Use `priceRangeV2` instead.")
    priceRangeV2: ProductPriceRangeV2!
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    productPublications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductPublicationConnection! @deprecated(reason: "Use `resourcePublications` instead")
    productType: String!
    publicationCount(onlyPublished: Boolean = true): Int!
    publications(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductPublicationConnection! @deprecated(reason: "Use `resourcePublications` instead")
    publishedAt: DateTime
    publishedOnChannel(channelId: ID!): Boolean! @deprecated(reason: "Use `publishedOnPublication` instead")
    publishedOnCurrentChannel: Boolean! @deprecated(reason: "Use `publishedOnCurrentPublication` instead")
    publishedOnCurrentPublication: Boolean!
    publishedOnPublication(publicationId: ID!): Boolean!
    requiresSellingPlan: Boolean!
    resourcePublications(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationConnection!
    resourcePublicationsV2(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationV2Connection!
    sellingPlanGroupCount: Int!
    seo: SEO!
    status: ProductStatus!
    storefrontId: StorefrontID!
    tags: [String!]!
    templateSuffix: String
    title: String!
    totalInventory: Int!
    totalVariants: Int!
    tracksInventory: Boolean!
    translations(locale: String!): [PublishedTranslation!]!
    unpublishedChannels(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ChannelConnection! @deprecated(reason: "Use `unpublishedPublications` instead")
    unpublishedPublications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PublicationConnection!
    updatedAt: DateTime!
    variants(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductVariantSortKeys = POSITION): ProductVariantConnection!
    vendor: String!
}

input ProductAppendImagesInput {
    id: ID!
    images: [ImageInput!]!
}

type ProductAppendImagesPayload {
    newImages(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): [Image!]
    product: Product
    userErrors: [UserError!]!
}

type ProductChangeStatusPayload {
    product: Product
    userErrors: [ProductChangeStatusUserError!]!
}

type ProductChangeStatusUserError implements DisplayableError {
    code: ProductChangeStatusUserErrorCode
    field: [String!]
    message: String!
}

enum ProductChangeStatusUserErrorCode {
    PRODUCT_NOT_FOUND
}

enum ProductCollectionSortKeys {
    TITLE
    PRICE
    BEST_SELLING
    CREATED
    ID
    MANUAL
    COLLECTION_DEFAULT
    RELEVANCE
}

type ProductConnection {
    edges: [ProductEdge!]!
    pageInfo: PageInfo!
}

type ProductCreateMediaPayload {
    media: [Media!]
    mediaUserErrors: [MediaUserError!]!
    product: Product
    userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead")
}

type ProductCreatePayload {
    product: Product
    shop: Shop!
    userErrors: [UserError!]!
}

type ProductDeleteImagesPayload {
    deletedImageIds: [ID!]!
    product: Product
    userErrors: [UserError!]!
}

input ProductDeleteInput {
    id: ID!
}

type ProductDeleteMediaPayload {
    deletedMediaIds: [ID!]
    deletedProductImageIds: [ID!]
    mediaUserErrors: [MediaUserError!]!
    product: Product
    userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead")
}

type ProductDeletePayload {
    deletedProductId: ID
    shop: Shop!
    userErrors: [UserError!]!
}

type ProductDuplicatePayload {
    imageJob: Job
    newProduct: Product
    shop: Shop!
    userErrors: [UserError!]!
}

type ProductEdge {
    cursor: String!
    node: Product!
}

enum ProductImageSortKeys {
    CREATED_AT
    POSITION
    ID
    RELEVANCE
}

type ProductImageUpdatePayload {
    image(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    userErrors: [UserError!]!
}

input ProductInput {
    descriptionHtml: String
    handle: String
    redirectNewHandle: Boolean = false
    seo: SEOInput
    productType: String
    tags: [String!]
    templateSuffix: String
    giftCard: Boolean
    giftCardTemplateSuffix: String
    title: String
    vendor: String
    bodyHtml: String
    collectionsToJoin: [ID!]
    collectionsToLeave: [ID!]
    id: ID
    images: [ImageInput!]
    metafields: [MetafieldInput!]
    privateMetafields: [PrivateMetafieldInput!]
    options: [String!]
    productPublications: [ProductPublicationInput!]
    publications: [ProductPublicationInput!]
    publishDate: DateTime
    publishOn: DateTime
    published: Boolean
    publishedAt: DateTime
    variants: [ProductVariantInput!]
    status: ProductStatus
    requiresSellingPlan: Boolean
}

type ProductJoinSellingPlanGroupsPayload {
    product: Product
    userErrors: [SellingPlanGroupUserError!]!
}

type ProductLeaveSellingPlanGroupsPayload {
    product: Product
    userErrors: [SellingPlanGroupUserError!]!
}

enum ProductMediaSortKeys {
    POSITION
    ID
    RELEVANCE
}

type ProductOption implements Node & HasPublishedTranslations {
    id: ID!
    name: String!
    position: Int!
    translations(locale: String!): [PublishedTranslation!]!
    values: [String!]!
}

type ProductPriceRange {
    maxVariantPrice: MoneyV2!
    minVariantPrice: MoneyV2!
}

type ProductPriceRangeV2 {
    maxVariantPrice: MoneyV2!
    minVariantPrice: MoneyV2!
}

type ProductPublication {
    channel: Channel!
    isPublished: Boolean!
    product: Product!
    publishDate: DateTime
}

type ProductPublicationConnection {
    edges: [ProductPublicationEdge!]!
    pageInfo: PageInfo!
}

type ProductPublicationEdge {
    cursor: String!
    node: ProductPublication!
}

input ProductPublicationInput {
    publicationId: ID
    channelId: ID
    channelHandle: String
    publishDate: DateTime
}

input ProductPublishInput {
    id: ID!
    productPublications: [ProductPublicationInput!]!
}

type ProductPublishPayload {
    product: Product
    productPublications: [ProductPublication!] @deprecated(reason: "Use Product.publications instead.")
    shop: Shop!
    userErrors: [UserError!]!
}

type ProductReorderImagesPayload {
    job: Job
    userErrors: [UserError!]!
}

type ProductReorderMediaPayload {
    job: Job
    mediaUserErrors: [MediaUserError!]!
    userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead")
}

type ProductSale implements Sale {
    actionType: SaleActionType!
    id: ID!
    lineItem: LineItem!
    lineType: SaleLineType!
    quantity: Int
    taxes: [SaleTax!]!
    totalAmount: MoneyBag!
    totalDiscountAmountAfterTaxes: MoneyBag!
    totalDiscountAmountBeforeTaxes: MoneyBag!
    totalTaxAmount: MoneyBag!
}

enum ProductSortKeys {
    TITLE
    PRODUCT_TYPE
    VENDOR
    INVENTORY_TOTAL
    UPDATED_AT
    CREATED_AT
    PUBLISHED_AT
    ID
    RELEVANCE
}

enum ProductStatus {
    ACTIVE
    ARCHIVED
    DRAFT
}

input ProductUnpublishInput {
    id: ID!
    productPublications: [ProductPublicationInput!]!
}

type ProductUnpublishPayload {
    product: Product
    shop: Shop!
    userErrors: [UserError!]!
}

type ProductUpdateMediaPayload {
    media: [Media!]
    mediaUserErrors: [MediaUserError!]!
    product: Product
    userErrors: [UserError!]! @deprecated(reason: "Use `mediaUserErrors` instead")
}

type ProductUpdatePayload {
    product: Product
    userErrors: [UserError!]!
}

type ProductVariant implements Node & HasMetafields & HasPublishedTranslations & Navigable & LegacyInteroperability {
    availableForSale: Boolean!
    barcode: String
    compareAtPrice: Money
    createdAt: DateTime!
    defaultCursor: String!
    deliveryProfile: DeliveryProfile
    displayName: String!
    fulfillmentService: FulfillmentService
    fulfillmentServiceEditable: EditableProperty!
    harmonizedSystemCode: String @deprecated(reason: "Use `InventoryItem.harmonizedSystemCode` instead.")
    id: ID!
    image(maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): Image
    inventoryItem: InventoryItem!
    inventoryManagement: ProductVariantInventoryManagement! @deprecated(reason: "Use tracked attribute on `inventoryItem` instead.")
    inventoryPolicy: ProductVariantInventoryPolicy!
    inventoryQuantity: Int
    legacyResourceId: UnsignedInt64!
    media(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MediaConnection!
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    position: Int!
    presentmentPrices(presentmentCurrencies: [CurrencyCode!], first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductVariantPricePairConnection!
    price: Money!
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    product: Product!
    requiresShipping: Boolean! @deprecated(reason: "Use `InventoryItem.requiresShipping` instead.")
    selectedOptions: [SelectedOption!]!
    sellingPlanGroupCount: Int!
    sku: String
    storefrontId: StorefrontID!
    taxCode: String
    taxable: Boolean!
    title: String!
    translations(locale: String!): [PublishedTranslation!]!
    updatedAt: DateTime!
    weight: Float
    weightUnit: WeightUnit!
}

input ProductVariantAppendMediaInput {
    variantId: ID!
    mediaIds: [ID!]!
}

type ProductVariantAppendMediaPayload {
    product: Product
    productVariants: [ProductVariant!]
    userErrors: [MediaUserError!]!
}

type ProductVariantConnection {
    edges: [ProductVariantEdge!]!
    pageInfo: PageInfo!
}

type ProductVariantCreatePayload {
    product: Product
    productVariant: ProductVariant
    userErrors: [UserError!]!
}

type ProductVariantDeletePayload {
    deletedProductVariantId: ID
    product: Product
    userErrors: [UserError!]!
}

input ProductVariantDetachMediaInput {
    variantId: ID!
    mediaIds: [ID!]!
}

type ProductVariantDetachMediaPayload {
    product: Product
    productVariants: [ProductVariant!]
    userErrors: [MediaUserError!]!
}

type ProductVariantEdge {
    cursor: String!
    node: ProductVariant!
}

input ProductVariantInput {
    barcode: String
    compareAtPrice: Money
    fulfillmentServiceId: ID
    harmonizedSystemCode: String
    id: ID
    imageId: ID
    imageSrc: String
    mediaSrc: [String!]
    inventoryManagement: ProductVariantInventoryManagement
    inventoryPolicy: ProductVariantInventoryPolicy
    inventoryQuantities: [InventoryLevelInput!]
    inventoryItem: InventoryItemInput
    metafields: [MetafieldInput!]
    privateMetafields: [PrivateMetafieldInput!]
    options: [String!]
    position: Int
    price: Money
    productId: ID
    requiresShipping: Boolean
    sku: String
    taxable: Boolean
    title: String
    taxCode: String
    weight: Float
    weightUnit: WeightUnit
}

enum ProductVariantInventoryManagement {
    SHOPIFY
    NOT_MANAGED
    FULFILLMENT_SERVICE
}

enum ProductVariantInventoryPolicy {
    DENY
    CONTINUE
}

type ProductVariantJoinSellingPlanGroupsPayload {
    productVariant: ProductVariant
    userErrors: [SellingPlanGroupUserError!]!
}

type ProductVariantLeaveSellingPlanGroupsPayload {
    productVariant: ProductVariant
    userErrors: [SellingPlanGroupUserError!]!
}

input ProductVariantPositionInput {
    id: ID!
    position: Int!
}

type ProductVariantPricePair {
    compareAtPrice: MoneyV2
    price: MoneyV2!
}

type ProductVariantPricePairConnection {
    edges: [ProductVariantPricePairEdge!]!
    pageInfo: PageInfo!
}

type ProductVariantPricePairEdge {
    cursor: String!
    node: ProductVariantPricePair!
}

type ProductVariantsBulkCreatePayload {
    product: Product
    productVariants: [ProductVariant!]
    userErrors: [ProductVariantsBulkCreateUserError!]!
}

type ProductVariantsBulkCreateUserError implements DisplayableError {
    code: ProductVariantsBulkCreateUserErrorCode
    field: [String!]
    message: String!
}

enum ProductVariantsBulkCreateUserErrorCode {
    PRODUCT_DOES_NOT_EXIST
    NO_KEY_ON_CREATE
    VARIANT_ALREADY_EXISTS
    GREATER_THAN_OR_EQUAL_TO
    NEED_TO_ADD_OPTION_VALUES
    OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS
    TOO_MANY_INVENTORY_LOCATIONS
    SUBSCRIPTION_VIOLATION
    VARIANT_ALREADY_EXISTS_CHANGE_OPTION_VALUE
    TRACKED_VARIANT_LOCATION_NOT_FOUND
    MUST_BE_FOR_THIS_PRODUCT
    NOT_DEFINED_FOR_SHOP
    INVALID
    NEGATIVE_PRICE_VALUE
}

type ProductVariantsBulkDeletePayload {
    product: Product
    userErrors: [ProductVariantsBulkDeleteUserError!]!
}

type ProductVariantsBulkDeleteUserError implements DisplayableError {
    code: ProductVariantsBulkDeleteUserErrorCode
    field: [String!]
    message: String!
}

enum ProductVariantsBulkDeleteUserErrorCode {
    PRODUCT_DOES_NOT_EXIST
    CANNOT_DELETE_LAST_VARIANT
    AT_LEAST_ONE_VARIANT_DOES_NOT_BELONG_TO_THE_PRODUCT
}

input ProductVariantsBulkInput {
    barcode: String
    compareAtPrice: Money
    fulfillmentServiceId: ID
    harmonizedSystemCode: String
    id: ID
    imageId: ID
    imageSrc: String
    mediaSrc: [String!]
    inventoryPolicy: ProductVariantInventoryPolicy
    inventoryQuantities: [InventoryLevelInput!]
    inventoryItem: InventoryItemInput
    metafields: [MetafieldInput!]
    privateMetafields: [PrivateMetafieldInput!]
    options: [String!]
    price: Money
    requiresShipping: Boolean
    sku: String
    taxable: Boolean
    taxCode: String
    weight: Float
    weightUnit: WeightUnit
}

type ProductVariantsBulkReorderPayload {
    product: Product
    userErrors: [ProductVariantsBulkReorderUserError!]!
}

type ProductVariantsBulkReorderUserError implements DisplayableError {
    code: ProductVariantsBulkReorderUserErrorCode
    field: [String!]
    message: String!
}

enum ProductVariantsBulkReorderUserErrorCode {
    PRODUCT_DOES_NOT_EXIST
    MISSING_VARIANT
    INVALID_POSITION
    DUPLICATED_VARIANT_ID
}

type ProductVariantsBulkUpdatePayload {
    product: Product
    productVariants: [ProductVariant!]
    userErrors: [ProductVariantsBulkUpdateUserError!]!
}

type ProductVariantsBulkUpdateUserError implements DisplayableError {
    code: ProductVariantsBulkUpdateUserErrorCode
    field: [String!]
    message: String!
}

enum ProductVariantsBulkUpdateUserErrorCode {
    PRODUCT_DOES_NOT_EXIST
    PRODUCT_VARIANT_ID_MISSING
    PRODUCT_VARIANT_DOES_NOT_EXIST
    NO_INVENTORY_QUANTITIES_ON_VARIANTS_UPDATE
    VARIANT_ALREADY_EXISTS
    GREATER_THAN_OR_EQUAL_TO
    NEED_TO_ADD_OPTION_VALUES
    OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS
    SUBSCRIPTION_VIOLATION
    NO_INVENTORY_QUANTITES_DURING_UPDATE
    NEGATIVE_PRICE_VALUE
}

enum ProductVariantSortKeys {
    TITLE
    NAME
    SKU
    INVENTORY_QUANTITY
    INVENTORY_MANAGEMENT
    INVENTORY_LEVELS_AVAILABLE
    INVENTORY_POLICY
    FULL_TITLE
    POPULAR
    POSITION
    ID
    RELEVANCE
}

type ProductVariantUpdatePayload {
    product: Product
    productVariant: ProductVariant
    userErrors: [UserError!]!
}

enum ProfileItemSortKeys {
    TITLE
    PRODUCT_TYPE
    VENDOR
    INVENTORY_TOTAL
    UPDATED_AT
    CREATED_AT
    PUBLISHED_AT
    ID
    RELEVANCE
}

type Publication implements Node {
    app: App!
    collectionPublicationsV3(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationConnection!
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CollectionConnection!
    hasCollection(id: ID!): Boolean!
    id: ID!
    name: String!
    productPublicationsV3(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductConnection!
    supportsFuturePublishing: Boolean!
}

type PublicationConnection {
    edges: [PublicationEdge!]!
    pageInfo: PageInfo!
}

type PublicationEdge {
    cursor: String!
    node: Publication!
}

input PublicationInput {
    channelId: ID
    publicationId: ID
    publishDate: DateTime
}

interface Publishable {
    availablePublicationCount: Int!
    publicationCount(onlyPublished: Boolean = true): Int!
    publishedOnChannel(channelId: ID!): Boolean! @deprecated(reason: "Use `publishedOnPublication` instead")
    publishedOnCurrentChannel: Boolean! @deprecated(reason: "Use `publishedOnCurrentPublication` instead")
    publishedOnCurrentPublication: Boolean!
    publishedOnPublication(publicationId: ID!): Boolean!
    resourcePublications(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationConnection!
    resourcePublicationsV2(onlyPublished: Boolean = true, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ResourcePublicationV2Connection!
    unpublishedChannels(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ChannelConnection! @deprecated(reason: "Use `unpublishedPublications` instead")
    unpublishedPublications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PublicationConnection!
}

type PublishablePublishPayload {
    publishable: Publishable
    shop: Shop!
    userErrors: [UserError!]!
}

type PublishablePublishToCurrentChannelPayload {
    publishable: Publishable
    shop: Shop!
    userErrors: [UserError!]!
}

type PublishableUnpublishPayload {
    publishable: Publishable
    shop: Shop!
    userErrors: [UserError!]!
}

type PublishableUnpublishToCurrentChannelPayload {
    publishable: Publishable
    shop: Shop!
    userErrors: [UserError!]!
}

type PublishedTranslation {
    key: String!
    locale: String!
    value: String
}

type PubSubWebhookSubscriptionCreatePayload {
    userErrors: [PubSubWebhookSubscriptionCreateUserError!]!
    webhookSubscription: WebhookSubscription
}

type PubSubWebhookSubscriptionCreateUserError implements DisplayableError {
    code: PubSubWebhookSubscriptionCreateUserErrorCode
    field: [String!]
    message: String!
}

enum PubSubWebhookSubscriptionCreateUserErrorCode {
    INVALID_PARAMETERS
}

input PubSubWebhookSubscriptionInput {
    pubSubProject: String!
    pubSubTopic: String!
    format: WebhookSubscriptionFormat
    includeFields: [String!]
    metafieldNamespaces: [String!]
}

type PubSubWebhookSubscriptionUpdatePayload {
    userErrors: [PubSubWebhookSubscriptionUpdateUserError!]!
    webhookSubscription: WebhookSubscription
}

type PubSubWebhookSubscriptionUpdateUserError implements DisplayableError {
    code: PubSubWebhookSubscriptionUpdateUserErrorCode
    field: [String!]
    message: String!
}

enum PubSubWebhookSubscriptionUpdateUserErrorCode {
    INVALID_PARAMETERS
}

type QueryRoot {
    app(id: ID): App
    appByHandle(handle: String!): App
    appByKey(apiKey: String!): App
    appInstallation(id: ID): AppInstallation
    appInstallations(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AppInstallationSortKeys = INSTALLED_AT, category: AppInstallationCategory, privacy: AppInstallationPrivacy = PUBLIC): AppInstallationConnection!
    automaticDiscount(id: ID!): DiscountAutomatic @deprecated(reason: "Use `automaticDiscountNode` instead")
    automaticDiscountNode(id: ID!): DiscountAutomaticNode
    automaticDiscountNodes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AutomaticDiscountSortKeys = CREATED_AT, query: String, savedSearchId: ID): DiscountAutomaticNodeConnection!
    automaticDiscountSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    automaticDiscounts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: AutomaticDiscountSortKeys = CREATED_AT, query: String, savedSearchId: ID): DiscountAutomaticConnection! @deprecated(reason: "Use `automaticDiscountNodes` instead")
    availableCarrierServices: [DeliveryCarrierServiceAndLocations!]!
    availableLocales: [Locale!]!
    carrierService(id: ID!): DeliveryCarrierService
    channel(id: ID!): Channel @deprecated(reason: "Use `publication` instead")
    channels(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ChannelConnection! @deprecated(reason: "Use `publications` instead")
    codeDiscountNode(id: ID!): DiscountCodeNode
    codeDiscountNodeByCode(code: String!): DiscountCodeNode
    codeDiscountNodes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CodeDiscountSortKeys = CREATED_AT, query: String, savedSearchId: ID): DiscountCodeNodeConnection!
    codeDiscountSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    collection(id: ID!): Collection
    collectionByHandle(handle: String!): Collection
    collectionRulesConditions: [CollectionRuleConditions!]!
    collectionSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CollectionSortKeys = ID, query: String, savedSearchId: ID): CollectionConnection!
    currentAppInstallation: AppInstallation!
    currentBulkOperation(type: BulkOperationType = QUERY): BulkOperation
    customer(id: ID!): Customer
    customerPaymentMethod(id: ID!, showRevoked: Boolean = false): CustomerPaymentMethod
    customerSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CustomerSavedSearchSortKeys = ID, query: String): SavedSearchConnection!
    customers(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CustomerSortKeys = ID, query: String): CustomerConnection!
    deletionEvents(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DeletionEventSortKeys = ID, query: String, subjectTypes: [DeletionEventSubjectType!]): DeletionEventConnection!
    deliveryProfile(id: ID!): DeliveryProfile
    deliveryProfiles(merchantOwnedOnly: Boolean, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): DeliveryProfileConnection!
    deliverySettings: DeliverySetting
    discountCodeCount(query: String): Int!
    discountRedeemCodeBulkCreation(id: ID!): DiscountRedeemCodeBulkCreation
    discountRedeemCodeSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DiscountCodeSortKeys = ID, query: String): SavedSearchConnection!
    domain(id: ID!): Domain
    draftOrder(id: ID!): DraftOrder
    draftOrderSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    draftOrders(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DraftOrderSortKeys = ID, query: String): DraftOrderConnection!
    fileSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    files(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: FileSortKeys = ID, query: String, savedSearchId: ID): FileConnection!
    fulfillment(id: ID!): Fulfillment
    fulfillmentOrder(id: ID!): FulfillmentOrder
    fulfillmentService(id: ID!): FulfillmentService
    giftCard(id: ID!): GiftCard
    giftCards(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: GiftCardSortKeys = ID, query: String, savedSearchId: ID): GiftCardConnection!
    giftCardsCount(enabled: Boolean): UnsignedInt64!
    inventoryItem(id: ID!): InventoryItem
    inventoryItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): InventoryItemConnection!
    inventoryLevel(id: ID!): InventoryLevel
    job(id: ID!): Job
    location(id: ID): Location
    locations(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: LocationSortKeys = NAME, query: String, includeLegacy: Boolean = false, includeInactive: Boolean = false): LocationConnection!
    locationsAvailableForDeliveryProfiles: [Location!] @deprecated(reason: "Use `locationsAvailableForDeliveryProfilesConnection` instead")
    locationsAvailableForDeliveryProfilesConnection(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): LocationConnection!
    marketingActivities(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: MarketingActivitySortKeys = CREATED_AT, query: String, savedSearchId: ID): MarketingActivityConnection!
    marketingActivity(id: ID!): MarketingActivity
    marketingEvent(id: ID!): MarketingEvent
    marketingEvents(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: MarketingEventSortKeys = ID, query: String): MarketingEventConnection!
    metafield(id: ID!): Metafield
    metafieldStorefrontVisibilities(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldStorefrontVisibilityConnection!
    metafieldStorefrontVisibility(id: ID!): MetafieldStorefrontVisibility
    node(id: ID!): Node
    nodes(ids: [ID!]!): [Node]!
    order(id: ID!): Order
    orderSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    orders(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: OrderSortKeys = PROCESSED_AT, query: String, savedSearchId: ID): OrderConnection!
    priceList(id: ID!): PriceList
    priceLists(matchRule: PriceListContext, first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: PriceListSortKeys = ID): PriceListConnection!
    priceRule(id: ID!): PriceRule
    priceRuleSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    priceRules(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: PriceRuleSortKeys = ID, query: String, savedSearchId: ID): PriceRuleConnection!
    privateMetafield(id: ID!): PrivateMetafield
    privateMetafields(namespace: String, owner: ID!, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    product(id: ID!): Product
    productByHandle(handle: String!): Product
    productSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    productVariant(id: ID!): ProductVariant
    productVariants(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductVariantSortKeys = ID, query: String, savedSearchId: ID): ProductVariantConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductSortKeys = ID, query: String, savedSearchId: ID): ProductConnection!
    publicApiVersions: [ApiVersion!]!
    publication(id: ID!): Publication
    publications(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PublicationConnection!
    refund(id: ID!): Refund
    scriptTag(id: ID!): ScriptTag
    scriptTags(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, src: URL): ScriptTagConnection!
    sellingPlanGroup(id: ID!): SellingPlanGroup
    sellingPlanGroups(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: SellingPlanGroupSortKeys = ID, query: String): SellingPlanGroupConnection!
    shop: Shop!
    shopLocales(published: Boolean): [ShopLocale!]!
    shopifyPaymentsAccount: ShopifyPaymentsAccount
    subscriptionBillingAttempt(id: ID!): SubscriptionBillingAttempt
    subscriptionContract(id: ID!): SubscriptionContract
    subscriptionContracts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionContractConnection!
    subscriptionDraft(id: ID!): SubscriptionDraft
    tenderTransactions(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): TenderTransactionConnection!
    translatableResource(resourceId: ID!): TranslatableResource
    translatableResources(resourceType: TranslatableResourceType!, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): TranslatableResourceConnection!
    urlRedirect(id: ID!): UrlRedirect
    urlRedirectImport(id: ID!): UrlRedirectImport
    urlRedirectSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection!
    urlRedirects(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: UrlRedirectSortKeys = ID, query: String, savedSearchId: ID): UrlRedirectConnection!
    webhookSubscription(id: ID!): WebhookSubscription
    webhookSubscriptions(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: WebhookSubscriptionSortKeys = CREATED_AT, query: String, callbackUrl: URL, format: WebhookSubscriptionFormat, topics: [WebhookSubscriptionTopic!]): WebhookSubscriptionConnection!
}

type Refund implements Node & LegacyInteroperability {
    createdAt: DateTime
    duties: [RefundDuty!]
    id: ID!
    legacyResourceId: UnsignedInt64!
    note: String
    order: Order!
    refundLineItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): RefundLineItemConnection!
    totalRefunded: MoneyV2! @deprecated(reason: "Use `totalRefundedSet` instead")
    totalRefundedSet: MoneyBag!
    transactions(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): OrderTransactionConnection!
    updatedAt: DateTime!
}

type RefundAgreement implements SalesAgreement {
    app: App
    happenedAt: DateTime!
    id: ID!
    reason: OrderActionType!
    refund: Refund!
    sales(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SaleConnection!
}

type RefundCreatePayload {
    order: Order
    refund: Refund
    userErrors: [UserError!]!
}

type RefundDuty {
    amountSet: MoneyBag!
    originalDuty: Duty
}

input RefundDutyInput {
    dutyId: ID!
    refundType: RefundDutyRefundType
}

enum RefundDutyRefundType {
    PROPORTIONAL
    FULL
}

input RefundInput {
    currency: CurrencyCode
    orderId: ID!
    note: String
    notify: Boolean
    shipping: ShippingRefundInput
    refundLineItems: [RefundLineItemInput!]
    refundDuties: [RefundDutyInput!]
    transactions: [OrderTransactionInput!]
}

type RefundLineItem {
    lineItem: LineItem!
    location: Location
    price: Money! @deprecated(reason: "Use `priceSet` instead")
    priceSet: MoneyBag!
    quantity: Int!
    restockType: RefundLineItemRestockType!
    restocked: Boolean!
    subtotal: Money! @deprecated(reason: "Use `subtotalSet` instead")
    subtotalSet: MoneyBag!
    totalTax: Money! @deprecated(reason: "Use `totalTaxSet` instead")
    totalTaxSet: MoneyBag!
}

type RefundLineItemConnection {
    edges: [RefundLineItemEdge!]!
    pageInfo: PageInfo!
}

type RefundLineItemEdge {
    cursor: String!
    node: RefundLineItem!
}

input RefundLineItemInput {
    lineItemId: ID!
    quantity: Int!
    restockType: RefundLineItemRestockType
    locationId: ID
}

enum RefundLineItemRestockType {
    RETURN
    CANCEL
    LEGACY_RESTOCK
    NO_RESTOCK
}

type RefundSession {
    id: ID!
    status: RefundSessionStatus!
}

input RefundSessionRejectionReasonInput {
    code: RefundSessionStatusReasonRejectionCode!
    merchantMessage: String
}

type RefundSessionRejectPayload {
    refundSession: RefundSession
    userErrors: [RefundSessionRejectUserError!]!
}

type RefundSessionRejectUserError implements DisplayableError {
    code: RefundSessionRejectUserErrorCode
    field: [String!]
    message: String!
}

enum RefundSessionRejectUserErrorCode {
    REFUND_SESSION_NOT_FOUND
    REFUND_SESSION_INVALID_STATE
}

type RefundSessionResolvePayload {
    refundSession: RefundSession
    userErrors: [RefundSessionResolveUserError!]!
}

type RefundSessionResolveUserError implements DisplayableError {
    code: RefundSessionResolveUserErrorCode
    field: [String!]
    message: String!
}

enum RefundSessionResolveUserErrorCode {
    REFUND_SESSION_NOT_FOUND
    REFUND_SESSION_INVALID_STATE
}

type RefundSessionStatus {
    code: RefundSessionStatusCode!
    reason: RefundSessionStatusReason
}

enum RefundSessionStatusCode {
    REJECTED
    RESOLVED
}

type RefundSessionStatusReason {
    code: RefundSessionStatusReasonRejectionCode!
    merchantMessage: String
}

enum RefundSessionStatusReasonRejectionCode {
    PROCESSING_ERROR
}

input RemoteAuthorizeNetCustomerPaymentProfileInput {
    customerProfileId: String!
    customerPaymentProfileId: String
}

input RemoteStripePaymentMethodInput {
    customerId: String!
    paymentMethodId: String
}

type ResourceAlert {
    actions: [ResourceAlertAction!]!
    content: HTML!
    dismissibleHandle: String
    icon: ResourceAlertIcon
    severity: ResourceAlertSeverity!
    title: String!
}

type ResourceAlertAction {
    primary: Boolean!
    show: String
    title: String!
    url: URL!
}

enum ResourceAlertIcon {
    CHECKMARK_CIRCLE
    INFORMATION_CIRCLE
}

enum ResourceAlertSeverity {
    DEFAULT
    INFO
    WARNING
    SUCCESS
    CRITICAL
    ERROR @deprecated(reason: "`ERROR` severity is being deprecated in favour of `WARNING` or `CRITICAL` instead.")
}

type ResourceFeedback {
    appFeedback: [AppFeedback!]! @deprecated(reason: "Use `details` instead")
    details: [AppFeedback!]!
    summary: String!
}

type ResourceLimit {
    available: Boolean!
    quantityAvailable: Int
    quantityLimit: Int
    quantityUsed: Int
}

type ResourcePublication {
    channel: Channel! @deprecated(reason: "Use `publication` instead")
    isPublished: Boolean!
    publication: Publication!
    publishDate: DateTime!
    publishable: Publishable!
}

type ResourcePublicationConnection {
    edges: [ResourcePublicationEdge!]!
    pageInfo: PageInfo!
}

type ResourcePublicationEdge {
    cursor: String!
    node: ResourcePublication!
}

type ResourcePublicationV2 {
    isPublished: Boolean!
    publication: Publication!
    publishDate: DateTime
    publishable: Publishable!
}

type ResourcePublicationV2Connection {
    edges: [ResourcePublicationV2Edge!]!
    pageInfo: PageInfo!
}

type ResourcePublicationV2Edge {
    cursor: String!
    node: ResourcePublicationV2!
}

interface Sale {
    actionType: SaleActionType!
    id: ID!
    lineType: SaleLineType!
    quantity: Int
    taxes: [SaleTax!]!
    totalAmount: MoneyBag!
    totalDiscountAmountAfterTaxes: MoneyBag!
    totalDiscountAmountBeforeTaxes: MoneyBag!
    totalTaxAmount: MoneyBag!
}

enum SaleActionType {
    ORDER
    RETURN
    UPDATE
    UNKNOWN
}

type SaleConnection {
    edges: [SaleEdge!]!
    pageInfo: PageInfo!
}

type SaleEdge {
    cursor: String!
    node: Sale!
}

enum SaleLineType {
    PRODUCT
    TIP
    GIFT_CARD
    SHIPPING
    DUTY
    UNKNOWN
    ADJUSTMENT
}

interface SalesAgreement {
    app: App
    happenedAt: DateTime!
    id: ID!
    reason: OrderActionType!
    sales(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SaleConnection!
}

type SalesAgreementConnection {
    edges: [SalesAgreementEdge!]!
    pageInfo: PageInfo!
}

type SalesAgreementEdge {
    cursor: String!
    node: SalesAgreement!
}

type SaleTax {
    amount: MoneyBag!
    id: ID!
    taxLine: TaxLine!
}

type SavedSearch implements Node & LegacyInteroperability {
    filters: [SearchFilter!]!
    id: ID!
    legacyResourceId: UnsignedInt64!
    name: String!
    query: String!
    resourceType: SearchResultType!
    searchTerms: String!
}

type SavedSearchConnection {
    edges: [SavedSearchEdge!]!
    pageInfo: PageInfo!
}

input SavedSearchCreateInput {
    resourceType: SearchResultType!
    name: String!
    query: String!
}

type SavedSearchCreatePayload {
    savedSearch: SavedSearch
    userErrors: [UserError!]!
}

input SavedSearchDeleteInput {
    id: ID!
}

type SavedSearchDeletePayload {
    deletedSavedSearchId: ID
    shop: Shop!
    userErrors: [UserError!]!
}

type SavedSearchEdge {
    cursor: String!
    node: SavedSearch!
}

input SavedSearchUpdateInput {
    id: ID!
    name: String
    query: String
}

type SavedSearchUpdatePayload {
    savedSearch: SavedSearch
    userErrors: [UserError!]!
}

type ScriptDiscountApplication implements DiscountApplication {
    allocationMethod: DiscountApplicationAllocationMethod!
    description: String! @deprecated(reason: "Use `title` instead")
    index: Int!
    targetSelection: DiscountApplicationTargetSelection!
    targetType: DiscountApplicationTargetType!
    title: String!
    value: PricingValue!
}

type ScriptTag implements Node & LegacyInteroperability {
    cache: Boolean!
    createdAt: DateTime!
    displayScope: ScriptTagDisplayScope!
    id: ID!
    legacyResourceId: UnsignedInt64!
    src: URL!
    updatedAt: DateTime!
}

type ScriptTagConnection {
    edges: [ScriptTagEdge!]!
    pageInfo: PageInfo!
}

type ScriptTagCreatePayload {
    scriptTag: ScriptTag
    userErrors: [UserError!]!
}

type ScriptTagDeletePayload {
    deletedScriptTagId: ID
    userErrors: [UserError!]!
}

enum ScriptTagDisplayScope {
    ALL
    ORDER_STATUS
    ONLINE_STORE
}

type ScriptTagEdge {
    cursor: String!
    node: ScriptTag!
}

input ScriptTagInput {
    src: URL
    displayScope: ScriptTagDisplayScope
    cache: Boolean = false
}

type ScriptTagUpdatePayload {
    scriptTag: ScriptTag
    userErrors: [UserError!]!
}

type SearchFilter {
    key: String!
    value: String!
}

type SearchFilterOptions {
    productAvailability: [FilterOption!]!
}

type SearchResult {
    description: String
    image: Image
    reference: Node!
    title: String!
    url: URL!
}

type SearchResultConnection {
    edges: [SearchResultEdge!]!
    pageInfo: PageInfo!
    resultsAfterCount: Int! @deprecated(reason: "The provided information is not accurate.")
}

type SearchResultEdge {
    cursor: String!
    node: SearchResult!
}

enum SearchResultType {
    ORDER
    CUSTOMER
    PRODUCT
    ONLINE_STORE_PAGE
    ONLINE_STORE_BLOG
    ONLINE_STORE_ARTICLE
    COLLECTION
    DRAFT_ORDER
    PRICE_RULE
    DISCOUNT_REDEEM_CODE
    FILE
    URL_REDIRECT
}

type SelectedOption {
    name: String!
    value: String!
}

type SellingPlan implements Node {
    billingPolicy: SellingPlanBillingPolicy!
    createdAt: DateTime!
    deliveryPolicy: SellingPlanDeliveryPolicy!
    description: String
    id: ID!
    name: String!
    options: [String!]!
    position: Int
    pricingPolicies: [SellingPlanPricingPolicy!]!
}

type SellingPlanAnchor {
    day: Int!
    month: Int
    type: SellingPlanAnchorType!
}

input SellingPlanAnchorInput {
    type: SellingPlanAnchorType
    day: Int
    month: Int
}

enum SellingPlanAnchorType {
    WEEKDAY
    MONTHDAY
    YEARDAY
}

union SellingPlanBillingPolicy = SellingPlanRecurringBillingPolicy

input SellingPlanBillingPolicyInput {
    recurring: SellingPlanRecurringBillingPolicyInput
}

type SellingPlanConnection {
    edges: [SellingPlanEdge!]!
    pageInfo: PageInfo!
}

union SellingPlanDeliveryPolicy = SellingPlanRecurringDeliveryPolicy

input SellingPlanDeliveryPolicyInput {
    recurring: SellingPlanRecurringDeliveryPolicyInput
}

type SellingPlanEdge {
    cursor: String!
    node: SellingPlan!
}

type SellingPlanFixedPricingPolicy implements SellingPlanPricingPolicyBase {
    adjustmentType: SellingPlanPricingPolicyAdjustmentType!
    adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
    createdAt: DateTime!
}

input SellingPlanFixedPricingPolicyInput {
    id: ID
    adjustmentType: SellingPlanPricingPolicyAdjustmentType
    adjustmentValue: SellingPlanPricingPolicyValueInput
}

type SellingPlanGroup implements Node {
    appId: String
    appliesToProduct(productId: ID!): Boolean!
    appliesToProductVariant(productVariantId: ID!): Boolean!
    appliesToProductVariants(productId: ID!): Boolean!
    createdAt: DateTime!
    description: String
    id: ID!
    merchantCode: String!
    name: String!
    options: [String!]!
    position: Int
    productCount: Int!
    productVariantCount(productId: ID): Int!
    productVariants(productId: ID, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductVariantConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ProductConnection!
    sellingPlans(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SellingPlanConnection!
    summary: String
}

type SellingPlanGroupAddProductsPayload {
    sellingPlanGroup: SellingPlanGroup
    userErrors: [SellingPlanGroupUserError!]!
}

type SellingPlanGroupAddProductVariantsPayload {
    sellingPlanGroup: SellingPlanGroup
    userErrors: [SellingPlanGroupUserError!]!
}

type SellingPlanGroupConnection {
    edges: [SellingPlanGroupEdge!]!
    pageInfo: PageInfo!
}

type SellingPlanGroupCreatePayload {
    sellingPlanGroup: SellingPlanGroup
    userErrors: [SellingPlanGroupUserError!]!
}

type SellingPlanGroupDeletePayload {
    deletedSellingPlanGroupId: ID
    userErrors: [SellingPlanGroupUserError!]!
}

type SellingPlanGroupEdge {
    cursor: String!
    node: SellingPlanGroup!
}

input SellingPlanGroupInput {
    name: String
    appId: String
    merchantCode: String
    description: String
    sellingPlansToCreate: [SellingPlanInput!]
    sellingPlansToUpdate: [SellingPlanInput!]
    sellingPlansToDelete: [ID!]
    options: [String!]
    position: Int
}

type SellingPlanGroupRemoveProductsPayload {
    removedProductIds: [ID!]
    userErrors: [SellingPlanGroupUserError!]!
}

type SellingPlanGroupRemoveProductVariantsPayload {
    removedProductVariantIds: [ID!]
    userErrors: [SellingPlanGroupUserError!]!
}

input SellingPlanGroupResourceInput {
    productVariantIds: [ID!]
    productIds: [ID!]
}

enum SellingPlanGroupSortKeys {
    NAME
    UPDATED_AT
    CREATED_AT
    ID
    RELEVANCE
}

type SellingPlanGroupUpdatePayload {
    deletedSellingPlanIds: [ID!]
    sellingPlanGroup: SellingPlanGroup
    userErrors: [SellingPlanGroupUserError!]!
}

type SellingPlanGroupUserError implements DisplayableError {
    code: SellingPlanGroupUserErrorCode
    field: [String!]
    message: String!
}

enum SellingPlanGroupUserErrorCode {
    PRESENT
    BLANK
    INVALID
    GREATER_THAN
    GREATER_THAN_OR_EQUAL_TO
    LESS_THAN
    LESS_THAN_OR_EQUAL_TO
    NOT_A_NUMBER
    TOO_LONG
    TOO_SHORT
    TAKEN
    SELLING_PLAN_COUNT_UPPER_BOUND
    SELLING_PLAN_COUNT_LOWER_BOUND
    SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES
    SELLING_PLAN_BILLING_AND_DELIVERY_POLICY_ANCHORS_MUST_BE_EQUAL
    SELLING_PLAN_BILLING_CYCLE_MUST_BE_A_MULTIPLE_OF_DELIVERY_CYCLE
    SELLING_PLAN_PRICING_POLICIES_MUST_CONTAIN_A_FIXED_PRICING_POLICY
    SELLING_PLAN_MISSING_OPTION2_LABEL_ON_PARENT_GROUP
    SELLING_PLAN_MISSING_OPTION3_LABEL_ON_PARENT_GROUP
    SELLING_PLAN_OPTION2_REQUIRED_AS_DEFINED_ON_PARENT_GROUP
    SELLING_PLAN_OPTION3_REQUIRED_AS_DEFINED_ON_PARENT_GROUP
    SELLING_PLAN_PRICING_POLICIES_LIMIT
    RESOURCE_LIST_CONTAINS_INVALID_IDS
    PRODUCT_VARIANT_DOES_NOT_EXIST
    PRODUCT_DOES_NOT_EXIST
    GROUP_DOES_NOT_EXIST
    GROUP_COULD_NOT_BE_DELETED
    ERROR_ADDING_RESOURCE_TO_GROUP
    SELLING_PLAN_DELIVERY_POLICY_MISSING
    SELLING_PLAN_BILLING_POLICY_MISSING
    PLAN_DOES_NOT_EXIST
    PLAN_ID_MUST_BE_SPECIFIED_TO_UPDATE
    ONLY_NEED_ONE_PRICING_POLICY_TYPE
    ONLY_NEED_ONE_PRICING_POLICY_VALUE
    PRICING_POLICY_ADJUSTMENT_VALUE_AND_TYPE_MUST_MATCH
    SELLING_PLAN_DUPLICATE_NAME
    SELLING_PLAN_DUPLICATE_OPTIONS
}

input SellingPlanInput {
    id: ID
    name: String
    description: String
    billingPolicy: SellingPlanBillingPolicyInput
    deliveryPolicy: SellingPlanDeliveryPolicyInput
    pricingPolicies: [SellingPlanPricingPolicyInput!]
    options: [String!]
    position: Int
}

enum SellingPlanInterval {
    DAY
    WEEK
    MONTH
    YEAR
}

union SellingPlanPricingPolicy = SellingPlanFixedPricingPolicy | SellingPlanRecurringPricingPolicy

enum SellingPlanPricingPolicyAdjustmentType {
    PERCENTAGE
    FIXED_AMOUNT
    PRICE
}

union SellingPlanPricingPolicyAdjustmentValue = MoneyV2 | SellingPlanPricingPolicyPercentageValue

interface SellingPlanPricingPolicyBase {
    adjustmentType: SellingPlanPricingPolicyAdjustmentType!
    adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
}

input SellingPlanPricingPolicyInput {
    recurring: SellingPlanRecurringPricingPolicyInput
    fixed: SellingPlanFixedPricingPolicyInput
}

type SellingPlanPricingPolicyPercentageValue {
    percentage: Float!
}

input SellingPlanPricingPolicyValueInput {
    percentage: Float
    fixedValue: Decimal
}

type SellingPlanRecurringBillingPolicy {
    anchors: [SellingPlanAnchor!]!
    createdAt: DateTime!
    interval: SellingPlanInterval!
    intervalCount: Int!
    maxCycles: Int
    minCycles: Int
}

input SellingPlanRecurringBillingPolicyInput {
    interval: SellingPlanInterval
    intervalCount: Int
    anchors: [SellingPlanAnchorInput!]
    minCycles: Int
    maxCycles: Int
}

type SellingPlanRecurringDeliveryPolicy {
    anchors: [SellingPlanAnchor!]!
    createdAt: DateTime!
    cutoff: Int
    intent: SellingPlanRecurringDeliveryPolicyIntent!
    interval: SellingPlanInterval!
    intervalCount: Int!
    preAnchorBehavior: SellingPlanRecurringDeliveryPolicyPreAnchorBehavior!
}

input SellingPlanRecurringDeliveryPolicyInput {
    interval: SellingPlanInterval
    intervalCount: Int
    anchors: [SellingPlanAnchorInput!]
    cutoff: Int
    intent: SellingPlanRecurringDeliveryPolicyIntent
    preAnchorBehavior: SellingPlanRecurringDeliveryPolicyPreAnchorBehavior
}

enum SellingPlanRecurringDeliveryPolicyIntent {
    FULFILLMENT_BEGIN
}

enum SellingPlanRecurringDeliveryPolicyPreAnchorBehavior {
    ASAP
    NEXT
}

type SellingPlanRecurringPricingPolicy implements SellingPlanPricingPolicyBase {
    adjustmentType: SellingPlanPricingPolicyAdjustmentType!
    adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
    afterCycle: Int
    createdAt: DateTime!
}

input SellingPlanRecurringPricingPolicyInput {
    id: ID
    adjustmentType: SellingPlanPricingPolicyAdjustmentType
    adjustmentValue: SellingPlanPricingPolicyValueInput
    afterCycle: Int!
}

type SEO {
    description: String
    title: String
}

input SEOInput {
    title: String
    description: String
}

type ShippingLine {
    carrierIdentifier: String
    code: String
    custom: Boolean!
    deliveryCategory: String
    discountAllocations: [DiscountAllocation!]!
    discountedPrice: MoneyV2! @deprecated(reason: "Use `discountedPriceSet` instead")
    discountedPriceSet: MoneyBag!
    id: ID
    originalPrice: MoneyV2! @deprecated(reason: "Use `originalPriceSet` instead")
    originalPriceSet: MoneyBag!
    phone: String
    price: Money! @deprecated(reason: "Use `originalPriceSet` instead")
    requestedFulfillmentService: FulfillmentService
    shippingRateHandle: String
    source: String
    taxLines: [TaxLine!]!
    title: String!
}

type ShippingLineConnection {
    edges: [ShippingLineEdge!]!
    pageInfo: PageInfo!
}

type ShippingLineEdge {
    cursor: String!
    node: ShippingLine!
}

input ShippingLineInput {
    price: Money
    shippingRateHandle: String
    title: String
}

type ShippingLineSale implements Sale {
    actionType: SaleActionType!
    id: ID!
    lineType: SaleLineType!
    quantity: Int
    shippingLine: ShippingLine
    taxes: [SaleTax!]!
    totalAmount: MoneyBag!
    totalDiscountAmountAfterTaxes: MoneyBag!
    totalDiscountAmountBeforeTaxes: MoneyBag!
    totalTaxAmount: MoneyBag!
}

type ShippingMethod {
    code: String!
    label: String!
}

type ShippingPackageDeletePayload {
    deletedId: ID
    userErrors: [UserError!]!
}

type ShippingPackageMakeDefaultPayload {
    userErrors: [UserError!]!
}

type ShippingPackageUpdatePayload {
    userErrors: [UserError!]!
}

type ShippingRate {
    handle: String!
    price: MoneyV2!
    title: String!
}

type ShippingRefund {
    amount: Money! @deprecated(reason: "Use `amountSet` instead")
    amountSet: MoneyBag!
    maximumRefundable: Money! @deprecated(reason: "Use `maximumRefundableSet` instead")
    maximumRefundableSet: MoneyBag!
    tax: Money! @deprecated(reason: "Use `taxSet` instead")
    taxSet: MoneyBag!
}

input ShippingRefundInput {
    amount: Money
    fullRefund: Boolean
}

type Shop implements Node & HasPublishedTranslations & HasMetafields {
    alerts: [ShopAlert!]!
    analyticsToken: String!
    assignedFulfillmentOrders(assignmentStatus: FulfillmentOrderAssignmentStatus, locationIds: [ID!], first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: FulfillmentOrderSortKeys = ID): FulfillmentOrderConnection!
    availableChannelApps(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): AppConnection!
    billingAddress: MailingAddress!
    channelCount: Int! @deprecated(reason: "Use `publicationCount` instead")
    channels(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ChannelConnection! @deprecated(reason: "Use `QueryRoot.channels` instead.")
    checkoutApiSupported: Boolean!
    collectionByHandle(handle: String!): Collection @deprecated(reason: "Use `QueryRoot.collectionByHandle` instead.")
    collectionSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.collectionSavedSearches` instead.")
    collections(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CollectionSortKeys = ID, query: String, savedSearchId: ID): CollectionConnection! @deprecated(reason: "Use `QueryRoot.collections` instead.")
    contactEmail: String!
    countriesInShippingZones: CountriesInShippingZones!
    currencyCode: CurrencyCode!
    currencyFormats: CurrencyFormats!
    currencySettings(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): CurrencySettingConnection!
    customerAccounts: ShopCustomerAccountsSetting!
    customerSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CustomerSavedSearchSortKeys = ID, query: String): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.customerSavedSearches` instead.")
    customerTags(first: Int!): StringConnection!
    customers(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: CustomerSortKeys = ID, query: String): CustomerConnection! @deprecated(reason: "Use `QueryRoot.customers` instead.")
    description: String
    domains: [Domain!]!
    draftOrderSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.draftOrderSavedSearches` instead.")
    draftOrderTags(first: Int!): StringConnection!
    draftOrders(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: DraftOrderSortKeys = ID, query: String): DraftOrderConnection! @deprecated(reason: "Use `QueryRoot.draftOrders` instead.")
    email: String!
    enabledPresentmentCurrencies: [CurrencyCode!]!
    features: ShopFeatures!
    fulfillmentOrders(includeClosed: Boolean = false, first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: FulfillmentOrderSortKeys = ID, query: String): FulfillmentOrderConnection!
    fulfillmentServices: [FulfillmentService!]!
    ianaTimezone: String!
    id: ID!
    inventoryItems(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): InventoryItemConnection! @deprecated(reason: "Use `QueryRoot.inventoryItems` instead.")
    limitedPendingOrderCount: LimitedPendingOrderCount!
    locations(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: LocationSortKeys = NAME, query: String, includeLegacy: Boolean = false, includeInactive: Boolean = false): LocationConnection! @deprecated(reason: "Use `QueryRoot.locations` instead.")
    marketingEvents(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: MarketingEventSortKeys = ID, query: String): MarketingEventConnection! @deprecated(reason: "Use `QueryRoot.marketingEvents` instead.")
    metafield(namespace: String!, key: String!): Metafield
    metafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): MetafieldConnection!
    myshopifyDomain: String!
    name: String!
    navigationSettings: [NavigationItem!]!
    orderNumberFormatPrefix: String!
    orderNumberFormatSuffix: String!
    orderSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.orderSavedSearches` instead.")
    orderTags(first: Int!, sort: ShopTagSort = ALPHABETICAL): StringConnection!
    orders(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: OrderSortKeys = PROCESSED_AT, query: String): OrderConnection! @deprecated(reason: "Use `QueryRoot.orders` instead.")
    paymentSettings: PaymentSettings!
    pendingOrderCount: Int! @deprecated(reason: "Use `limitedPendingOrderCount` instead")
    plan: ShopPlan!
    priceRuleSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.priceRuleSavedSearches` instead.")
    priceRules(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: PriceRuleSortKeys = ID, query: String, savedSearchId: ID): PriceRuleConnection! @deprecated(reason: "Use `QueryRoot.priceRules` instead.")
    primaryDomain: Domain!
    privateMetafield(namespace: String!, key: String!): PrivateMetafield
    privateMetafields(namespace: String, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): PrivateMetafieldConnection!
    productByHandle(handle: String!): Product @deprecated(reason: "Use `QueryRoot.productByHandle` instead.")
    productImages(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductImageSortKeys = CREATED_AT, maxWidth: Int, maxHeight: Int, crop: CropRegion, scale: Int = 1): ImageConnection!
    productSavedSearches(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SavedSearchConnection! @deprecated(reason: "Use `QueryRoot.productSavedSearches` instead.")
    productTags(first: Int!): StringConnection!
    productTypes(first: Int!): StringConnection!
    productVariants(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductVariantSortKeys = ID, query: String): ProductVariantConnection! @deprecated(reason: "Use `QueryRoot.productVariants` instead.")
    productVendors(first: Int!): StringConnection!
    products(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, sortKey: ProductSortKeys = ID, query: String, savedSearchId: ID): ProductConnection! @deprecated(reason: "Use `QueryRoot.products`.")
    publicationCount: Int!
    resourceLimits: ShopResourceLimits!
    richTextEditorUrl: URL!
    search(query: String!, types: [SearchResultType!], first: Int!, after: String): SearchResultConnection!
    searchFilters: SearchFilterOptions!
    setupRequired: Boolean!
    shipsToCountries: [CountryCode!]!
    shopPolicies: [ShopPolicy!]!
    shopifyPaymentsAccount: ShopifyPaymentsAccount @deprecated(reason: "Use `QueryRoot.shopifyPaymentsAccount` instead.")
    storefrontAccessTokens(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): StorefrontAccessTokenConnection!
    storefrontUrl: URL! @deprecated(reason: "Use `url` instead")
    taxShipping: Boolean!
    taxesIncluded: Boolean!
    timezoneAbbreviation: String!
    timezoneOffset: String!
    timezoneOffsetMinutes: Int!
    translations(locale: String!): [PublishedTranslation!]!
    unitSystem: UnitSystem!
    uploadedImagesByIds(imageIds: [ID!]!): [Image!]!
    url: URL!
    weightUnit: WeightUnit!
}

type ShopAlert {
    action: ShopAlertAction!
    description: String!
}

type ShopAlertAction {
    title: String!
    url: URL!
}

enum ShopBranding {
    SHOPIFY_GOLD
    SHOPIFY_PLUS
    ROGERS
    SHOPIFY
}

enum ShopCustomerAccountsSetting {
    REQUIRED
    OPTIONAL
    DISABLED
}

type ShopFeatures {
    avalaraAvatax: Boolean!
    branding: ShopBranding!
    captcha: Boolean!
    captchaExternalDomains: Boolean!
    deliveryProfiles: Boolean! @deprecated(reason: "Delivery profiles are now 100% enabled across Shopify.")
    dynamicRemarketing: Boolean!
    eligibleForSubscriptionMigration: Boolean!
    eligibleForSubscriptions: Boolean!
    giftCards: Boolean!
    harmonizedSystemCode: Boolean!
    internationalDomains: Boolean!
    internationalPriceOverrides: Boolean!
    internationalPriceRules: Boolean!
    legacySubscriptionGatewayEnabled: Boolean!
    liveView: Boolean!
    multiLocation: Boolean!
    onboardingVisual: Boolean!
    paypalExpressSubscriptionGatewayStatus: PaypalExpressSubscriptionsGatewayStatus!
    reports: Boolean!
    sellsSubscriptions: Boolean!
    shopifyPlus: Boolean! @deprecated(reason: "Use Shop.plan.shopifyPlus instead.")
    showMetrics: Boolean!
    storefront: Boolean!
    usingShopifyBalance: Boolean!
}

type ShopifyPaymentsAccount implements Node {
    activated: Boolean!
    balance: [MoneyV2!]!
    bankAccounts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ShopifyPaymentsBankAccountConnection!
    chargeStatementDescriptor: String @deprecated(reason: "Use `chargeStatementDescriptors` instead")
    chargeStatementDescriptors: ShopifyPaymentsChargeStatementDescriptor
    country: String!
    defaultCurrency: CurrencyCode!
    disputes(first: Int, after: String, last: Int, before: String, reverse: Boolean = false, query: String): ShopifyPaymentsDisputeConnection!
    fraudSettings: ShopifyPaymentsFraudSettings!
    id: ID!
    notificationSettings: ShopifyPaymentsNotificationSettings!
    onboardable: Boolean!
    payoutSchedule: ShopifyPaymentsPayoutSchedule!
    payoutStatementDescriptor: String
    payouts(transactionType: ShopifyPaymentsPayoutTransactionType, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ShopifyPaymentsPayoutConnection!
    permittedVerificationDocuments: [ShopifyPaymentsVerificationDocument!]!
    verifications: [ShopifyPaymentsVerification!]!
}

type ShopifyPaymentsBankAccount implements Node {
    accountNumber: String!
    accountNumberLastDigits: String!
    bankName: String
    country: CountryCode!
    createdAt: DateTime!
    currency: CurrencyCode!
    id: ID!
    payouts(transactionType: ShopifyPaymentsPayoutTransactionType, first: Int, after: String, last: Int, before: String, reverse: Boolean = false): ShopifyPaymentsPayoutConnection!
    routingNumber: String!
    status: ShopifyPaymentsBankAccountStatus!
}

type ShopifyPaymentsBankAccountConnection {
    edges: [ShopifyPaymentsBankAccountEdge!]!
    pageInfo: PageInfo!
}

type ShopifyPaymentsBankAccountEdge {
    cursor: String!
    node: ShopifyPaymentsBankAccount!
}

enum ShopifyPaymentsBankAccountStatus {
    NEW
    VALIDATED
    VERIFIED
    ERRORED
}

interface ShopifyPaymentsChargeStatementDescriptor {
    default: String
    prefix: String!
}

type ShopifyPaymentsDefaultChargeStatementDescriptor implements ShopifyPaymentsChargeStatementDescriptor {
    default: String
    prefix: String!
}

type ShopifyPaymentsDispute implements LegacyInteroperability & Node {
    amount: MoneyV2!
    evidenceDueBy: Date
    evidenceSentOn: Date
    finalizedOn: Date
    id: ID!
    initiatedAt: DateTime!
    legacyResourceId: UnsignedInt64!
    order: Order
    reasonDetails: ShopifyPaymentsDisputeReasonDetails!
    status: DisputeStatus!
    type: DisputeType!
}

type ShopifyPaymentsDisputeConnection {
    edges: [ShopifyPaymentsDisputeEdge!]!
    pageInfo: PageInfo!
}

type ShopifyPaymentsDisputeEdge {
    cursor: String!
    node: ShopifyPaymentsDispute!
}

enum ShopifyPaymentsDisputeReason {
    FRAUDULENT
    GENERAL
    UNRECOGNIZED
    DUPLICATE
    SUBSCRIPTION_CANCELLED
    PRODUCT_UNACCEPTABLE
    PRODUCT_NOT_RECEIVED
    CREDIT_NOT_PROCESSED
    INCORRECT_ACCOUNT_DETAILS
    INSUFFICIENT_FUNDS
    BANK_CANNOT_PROCESS
    DEBIT_NOT_AUTHORIZED
    CUSTOMER_INITIATED
}

type ShopifyPaymentsDisputeReasonDetails {
    networkReasonCode: String
    reason: ShopifyPaymentsDisputeReason!
}

type ShopifyPaymentsExtendedAuthorization {
    extendedAuthorizationExpiresAt: DateTime!
    standardAuthorizationExpiresAt: DateTime!
}

type ShopifyPaymentsFraudSettings {
    declineChargeOnAvsFailure: Boolean!
    declineChargeOnCvcFailure: Boolean!
}

type ShopifyPaymentsJpChargeStatementDescriptor implements ShopifyPaymentsChargeStatementDescriptor {
    default: String
    kana: String
    kanji: String
    prefix: String!
}

type ShopifyPaymentsNotificationSettings {
    payouts: Boolean!
}

type ShopifyPaymentsPayout implements LegacyInteroperability & Node {
    bankAccount: ShopifyPaymentsBankAccount
    gross: MoneyV2! @deprecated(reason: "Use `net` instead")
    id: ID!
    issuedAt: DateTime!
    legacyResourceId: UnsignedInt64!
    net: MoneyV2!
    status: ShopifyPaymentsPayoutStatus!
    summary: ShopifyPaymentsPayoutSummary!
    transactionType: ShopifyPaymentsPayoutTransactionType!
}

type ShopifyPaymentsPayoutConnection {
    edges: [ShopifyPaymentsPayoutEdge!]!
    pageInfo: PageInfo!
}

type ShopifyPaymentsPayoutEdge {
    cursor: String!
    node: ShopifyPaymentsPayout!
}

enum ShopifyPaymentsPayoutInterval {
    DAILY
    WEEKLY
    MONTHLY
    MANUAL
}

type ShopifyPaymentsPayoutSchedule {
    interval: ShopifyPaymentsPayoutInterval!
    monthlyAnchor: Int
    weeklyAnchor: DayOfTheWeek
}

enum ShopifyPaymentsPayoutStatus {
    SCHEDULED
    IN_TRANSIT
    PAID
    FAILED
    CANCELED
}

type ShopifyPaymentsPayoutSummary {
    adjustmentsFee: MoneyV2!
    adjustmentsGross: MoneyV2!
    chargesFee: MoneyV2!
    chargesGross: MoneyV2!
    refundsFee: MoneyV2!
    refundsFeeGross: MoneyV2!
    reservedFundsFee: MoneyV2!
    reservedFundsGross: MoneyV2!
    retriedPayoutsFee: MoneyV2!
    retriedPayoutsGross: MoneyV2!
}

enum ShopifyPaymentsPayoutTransactionType {
    DEPOSIT
    WITHDRAWAL
}

type ShopifyPaymentsTransactionSet {
    extendedAuthorizationSet: ShopifyPaymentsExtendedAuthorization
}

type ShopifyPaymentsVerification implements Node {
    id: ID!
    status: ShopifyPaymentsVerificationStatus!
    subject: ShopifyPaymentsVerificationSubject!
}

type ShopifyPaymentsVerificationDocument {
    backRequired: Boolean!
    frontRequired: Boolean!
    type: ShopifyPaymentsVerificationDocumentType!
}

enum ShopifyPaymentsVerificationDocumentType {
    DRIVERS_LICENSE
    GOVERNMENT_IDENTIFICATION
    PASSPORT
}

enum ShopifyPaymentsVerificationStatus {
    VERIFIED
    UNVERIFIED
    PENDING
}

type ShopifyPaymentsVerificationSubject {
    familyName: String!
    givenName: String!
}

type ShopLocale {
    locale: String!
    name: String!
    primary: Boolean!
    published: Boolean!
}

type ShopLocaleDisablePayload {
    locale: String
    userErrors: [UserError!]!
}

type ShopLocaleEnablePayload {
    shopLocale: ShopLocale
    userErrors: [UserError!]!
}

input ShopLocaleInput {
    published: Boolean
}

type ShopLocaleUpdatePayload {
    shopLocale: ShopLocale
    userErrors: [UserError!]!
}

type ShopPlan {
    displayName: String!
    partnerDevelopment: Boolean!
    shopifyPlus: Boolean!
}

type ShopPolicy implements Node & HasPublishedTranslations {
    body: HTML!
    id: ID!
    translations(locale: String!): [PublishedTranslation!]!
    type: ShopPolicyType!
    url: URL!
}

enum ShopPolicyErrorCode {
    TOO_BIG
}

input ShopPolicyInput {
    type: ShopPolicyType!
    body: String!
}

enum ShopPolicyType {
    REFUND_POLICY
    SHIPPING_POLICY
    PRIVACY_POLICY
    TERMS_OF_SERVICE
    TERMS_OF_SALE
    LEGAL_NOTICE
    SUBSCRIPTION_POLICY
}

type ShopPolicyUpdatePayload {
    shopPolicy: ShopPolicy
    userErrors: [ShopPolicyUserError!]!
}

type ShopPolicyUserError implements DisplayableError {
    code: ShopPolicyErrorCode
    field: [String!]
    message: String!
}

type ShopResourceLimits {
    locationLimit: Int!
    maxProductOptions: Int!
    maxProductVariants: Int!
    redirectLimitReached: Boolean!
    skuResourceLimits: ResourceLimit!
}

enum ShopTagSort {
    ALPHABETICAL
    POPULAR
}

type StagedMediaUploadTarget {
    parameters: [StagedUploadParameter!]!
    resourceUrl: URL
    url: URL
}

enum StagedUploadHttpMethodType {
    POST
    PUT
}

input StagedUploadInput {
    resource: StagedUploadTargetGenerateUploadResource!
    filename: String!
    mimeType: String!
    httpMethod: StagedUploadHttpMethodType = PUT
    fileSize: UnsignedInt64
}

type StagedUploadParameter {
    name: String!
    value: String!
}

type StagedUploadsCreatePayload {
    stagedTargets: [StagedMediaUploadTarget!]
    userErrors: [UserError!]!
}

type StagedUploadTarget {
    parameters: [ImageUploadParameter!]!
    url: String!
}

input StagedUploadTargetGenerateInput {
    resource: StagedUploadTargetGenerateUploadResource!
    filename: String!
    mimeType: String!
    httpMethod: StagedUploadHttpMethodType = PUT
    fileSize: UnsignedInt64
}

type StagedUploadTargetGeneratePayload {
    parameters: [MutationsStagedUploadTargetGenerateUploadParameter!]!
    url: String!
    userErrors: [UserError!]!
}

enum StagedUploadTargetGenerateUploadResource {
    TIMELINE
    PRODUCT_IMAGE
    COLLECTION_IMAGE
    SHOP_IMAGE
    BULK_MUTATION_VARIABLES
    URL_REDIRECT_IMPORT
    FILE
    IMAGE
    MODEL_3D
    VIDEO
}

type StagedUploadTargetsGeneratePayload {
    urls: [StagedUploadTarget!]
    userErrors: [UserError!]!
}

input StageImageInput {
    resource: StagedUploadTargetGenerateUploadResource!
    filename: String!
    mimeType: String!
    httpMethod: StagedUploadHttpMethodType = PUT
}

type StorefrontAccessToken implements Node {
    accessScopes: [AccessScope!]!
    accessToken: String!
    createdAt: DateTime!
    id: ID!
    title: String!
    updatedAt: DateTime!
}

type StorefrontAccessTokenConnection {
    edges: [StorefrontAccessTokenEdge!]!
    pageInfo: PageInfo!
}

type StorefrontAccessTokenCreatePayload {
    shop: Shop!
    storefrontAccessToken: StorefrontAccessToken
    userErrors: [UserError!]!
}

input StorefrontAccessTokenDeleteInput {
    id: ID!
}

type StorefrontAccessTokenDeletePayload {
    deletedStorefrontAccessTokenId: ID
    userErrors: [UserError!]!
}

type StorefrontAccessTokenEdge {
    cursor: String!
    node: StorefrontAccessToken!
}

input StorefrontAccessTokenInput {
    title: String!
}

scalar StorefrontID

type StringConnection {
    edges: [StringEdge!]!
    pageInfo: PageInfo!
}

type StringEdge {
    cursor: String!
    node: String!
}

type SubscriptionAppliedCodeDiscount {
    id: ID!
    redeemCode: String!
    rejectionReason: SubscriptionDiscountRejectionReason
}

type SubscriptionBillingAttempt implements Node {
    completedAt: DateTime
    createdAt: DateTime!
    errorCode: SubscriptionBillingAttemptErrorCode
    errorMessage: String
    id: ID!
    idempotencyKey: String!
    nextActionUrl: URL
    order: Order
    ready: Boolean!
    subscriptionContract: SubscriptionContract!
}

type SubscriptionBillingAttemptConnection {
    edges: [SubscriptionBillingAttemptEdge!]!
    pageInfo: PageInfo!
}

type SubscriptionBillingAttemptCreatePayload {
    subscriptionBillingAttempt: SubscriptionBillingAttempt
    userErrors: [BillingAttemptUserError!]!
}

type SubscriptionBillingAttemptEdge {
    cursor: String!
    node: SubscriptionBillingAttempt!
}

enum SubscriptionBillingAttemptErrorCode {
    PAYMENT_METHOD_NOT_FOUND
    PAYMENT_PROVIDER_IS_NOT_ENABLED
    INVALID_PAYMENT_METHOD
    UNEXPECTED_ERROR
    EXPIRED_PAYMENT_METHOD
    PAYMENT_METHOD_DECLINED
    AUTHENTICATION_ERROR
    TEST_MODE
    BUYER_CANCELED_PAYMENT_METHOD
    CUSTOMER_NOT_FOUND
}

input SubscriptionBillingAttemptInput {
    idempotencyKey: String!
}

type SubscriptionBillingPolicy {
    anchors: [SellingPlanAnchor!]!
    interval: SellingPlanInterval!
    intervalCount: Int!
    maxCycles: Int
    minCycles: Int
}

input SubscriptionBillingPolicyInput {
    interval: SellingPlanInterval!
    intervalCount: Int!
    minCycles: Int
    maxCycles: Int
    anchors: [SellingPlanAnchorInput!] = []
}

type SubscriptionContract implements Node {
    app: App
    appAdminUrl: URL
    billingAttempts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionBillingAttemptConnection!
    billingPolicy: SubscriptionBillingPolicy!
    createdAt: DateTime!
    currencyCode: CurrencyCode!
    customer: Customer
    customerPaymentMethod(showRevoked: Boolean = false): CustomerPaymentMethod
    deliveryMethod: SubscriptionDeliveryMethod
    deliveryPolicy: SubscriptionDeliveryPolicy!
    deliveryPrice: MoneyV2!
    discounts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionManualDiscountConnection!
    id: ID!
    lastPaymentStatus: SubscriptionContractLastPaymentStatus
    lineCount: Int!
    lines(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionLineConnection!
    nextBillingDate: DateTime
    orders(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): OrderConnection!
    originOrder: Order
    status: SubscriptionContractSubscriptionStatus!
    updatedAt: DateTime!
}

type SubscriptionContractConnection {
    edges: [SubscriptionContractEdge!]!
    pageInfo: PageInfo!
}

input SubscriptionContractCreateInput {
    customerId: ID!
    nextBillingDate: DateTime!
    currencyCode: CurrencyCode!
    contract: SubscriptionDraftInput!
}

type SubscriptionContractCreatePayload {
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionContractEdge {
    cursor: String!
    node: SubscriptionContract!
}

enum SubscriptionContractErrorCode {
    INVALID
}

enum SubscriptionContractLastPaymentStatus {
    SUCCEEDED
    FAILED
}

type SubscriptionContractSetNextBillingDatePayload {
    contract: SubscriptionContract
    userErrors: [SubscriptionContractUserError!]!
}

enum SubscriptionContractSubscriptionStatus {
    ACTIVE
    PAUSED
    CANCELLED
    EXPIRED
    FAILED
}

type SubscriptionContractUpdatePayload {
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionContractUserError implements DisplayableError {
    code: SubscriptionContractErrorCode
    field: [String!]
    message: String!
}

type SubscriptionCyclePriceAdjustment {
    adjustmentType: SellingPlanPricingPolicyAdjustmentType!
    adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
    afterCycle: Int!
    computedPrice: MoneyV2!
}

union SubscriptionDeliveryMethod = SubscriptionDeliveryMethodShipping

input SubscriptionDeliveryMethodInput {
    shipping: SubscriptionDeliveryMethodShippingInput
}

type SubscriptionDeliveryMethodShipping {
    address: SubscriptionMailingAddress!
    shippingOption: SubscriptionDeliveryMethodShippingOption!
}

input SubscriptionDeliveryMethodShippingInput {
    address: MailingAddressInput
    shippingOption: SubscriptionDeliveryMethodShippingOptionInput
}

type SubscriptionDeliveryMethodShippingOption {
    carrierService: DeliveryCarrierService
    code: String
    description: String
    presentmentTitle: String
    title: String
}

input SubscriptionDeliveryMethodShippingOptionInput {
    title: String
    presentmentTitle: String
    description: String
    code: String
    carrierServiceId: ID
}

type SubscriptionDeliveryPolicy {
    anchors: [SellingPlanAnchor!]!
    interval: SellingPlanInterval!
    intervalCount: Int!
}

input SubscriptionDeliveryPolicyInput {
    interval: SellingPlanInterval!
    intervalCount: Int!
    anchors: [SellingPlanAnchorInput!] = []
}

union SubscriptionDiscount = SubscriptionAppliedCodeDiscount | SubscriptionManualDiscount

type SubscriptionDiscountAllocation {
    amount: MoneyV2!
    discount: SubscriptionDiscount!
}

type SubscriptionDiscountConnection {
    edges: [SubscriptionDiscountEdge!]!
    pageInfo: PageInfo!
}

type SubscriptionDiscountEdge {
    cursor: String!
    node: SubscriptionDiscount!
}

type SubscriptionDiscountEntitledLines {
    all: Boolean!
    lines(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionLineConnection!
}

type SubscriptionDiscountFixedAmountValue {
    amount: MoneyV2!
    appliesOnEachItem: Boolean!
}

type SubscriptionDiscountPercentageValue {
    percentage: Int!
}

enum SubscriptionDiscountRejectionReason {
    NOT_FOUND
    NO_ENTITLED_LINE_ITEMS
    QUANTITY_NOT_IN_RANGE
    PURCHASE_NOT_IN_RANGE
    CUSTOMER_NOT_ELIGIBLE
    USAGE_LIMIT_REACHED
    CUSTOMER_USAGE_LIMIT_REACHED
    CURRENTLY_INACTIVE
    NO_ENTITLED_SHIPPING_LINES
    INCOMPATIBLE_PURCHASE_TYPE
    INTERNAL_ERROR
}

union SubscriptionDiscountValue = SubscriptionDiscountFixedAmountValue | SubscriptionDiscountPercentageValue

type SubscriptionDraft implements Node {
    billingPolicy: SubscriptionBillingPolicy!
    currencyCode: CurrencyCode!
    customer: Customer!
    customerPaymentMethod(showRevoked: Boolean = false): CustomerPaymentMethod
    deliveryMethod: SubscriptionDeliveryMethod
    deliveryPolicy: SubscriptionDeliveryPolicy!
    deliveryPrice: MoneyV2
    discounts(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionDiscountConnection!
    discountsAdded(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionDiscountConnection!
    discountsRemoved(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionDiscountConnection!
    discountsUpdated(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionDiscountConnection!
    id: ID!
    lines(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionLineConnection!
    linesAdded(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionLineConnection!
    linesRemoved(first: Int, after: String, last: Int, before: String, reverse: Boolean = false): SubscriptionLineConnection!
    nextBillingDate: DateTime
    originalContract: SubscriptionContract
    shippingOptions(deliveryAddress: MailingAddressInput): SubscriptionShippingOptionResult
    status: SubscriptionContractSubscriptionStatus
}

type SubscriptionDraftCommitPayload {
    contract: SubscriptionContract
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftDiscountAddPayload {
    discountAdded: SubscriptionManualDiscount
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftDiscountCodeApplyPayload {
    appliedDiscount: SubscriptionAppliedCodeDiscount
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftDiscountRemovePayload {
    discountRemoved: SubscriptionDiscount
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftDiscountUpdatePayload {
    discountUpdated: SubscriptionManualDiscount
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

enum SubscriptionDraftErrorCode {
    ALREADY_REMOVED
    PRESENCE
    COMMITTED
    NOT_IN_RANGE
    NOT_AN_INTEGER
    SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES
    DELIVERY_MUST_BE_MULTIPLE_OF_BILLING
    INVALID_BILLING_DATE
    INVALID_LINES
    NO_ENTITLED_LINES
    CUSTOMER_DOES_NOT_EXIST
    CUSTOMER_MISMATCH
    DELIVERY_METHOD_REQUIRED
    CYCLE_DISCOUNTS_UNIQUE_AFTER_CYCLE
    INVALID_ADJUSTMENT_TYPE
    INVALID_ADJUSTMENT_VALUE
    STALE_CONTRACT
    CURRENCY_NOT_ENABLED
    INVALID
    BLANK
    GREATER_THAN
    GREATER_THAN_OR_EQUAL_TO
    LESS_THAN
    LESS_THAN_OR_EQUAL_TO
    TOO_LONG
    TOO_SHORT
}

type SubscriptionDraftFreeShippingDiscountAddPayload {
    discountAdded: SubscriptionManualDiscount
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftFreeShippingDiscountUpdatePayload {
    discountUpdated: SubscriptionManualDiscount
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

input SubscriptionDraftInput {
    status: SubscriptionContractSubscriptionStatus
    paymentMethodId: ID
    nextBillingDate: DateTime
    billingPolicy: SubscriptionBillingPolicyInput
    deliveryPolicy: SubscriptionDeliveryPolicyInput
    deliveryPrice: Decimal
    deliveryMethod: SubscriptionDeliveryMethodInput
}

type SubscriptionDraftLineAddPayload {
    draft: SubscriptionDraft
    lineAdded: SubscriptionLine
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftLineRemovePayload {
    discountsUpdated: [SubscriptionManualDiscount!]
    draft: SubscriptionDraft
    lineRemoved: SubscriptionLine
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftLineUpdatePayload {
    draft: SubscriptionDraft
    lineUpdated: SubscriptionLine
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftUpdatePayload {
    draft: SubscriptionDraft
    userErrors: [SubscriptionDraftUserError!]!
}

type SubscriptionDraftUserError implements DisplayableError {
    code: SubscriptionDraftErrorCode
    field: [String!]
    message: String!
}

input SubscriptionFreeShippingDiscountInput {
    title: String
    recurringCycleLimit: Int
}

type SubscriptionLine {
    currentPrice: MoneyV2!
    customAttributes: [Attribute!]!
    discountAllocations: [SubscriptionDiscountAllocation!]!
    id: ID!
    lineDiscountedPrice: MoneyV2!
    pricingPolicy: SubscriptionPricingPolicy
    productId: ID
    quantity: Int!
    requiresShipping: Boolean!
    sellingPlanId: ID
    sellingPlanName: String
    sku: String
    taxable: Boolean!
    title: String!
    variantId: ID
    variantImage: Image
    variantTitle: String
}

type SubscriptionLineConnection {
    edges: [SubscriptionLineEdge!]!
    pageInfo: PageInfo!
}

type SubscriptionLineEdge {
    cursor: String!
    node: SubscriptionLine!
}

input SubscriptionLineInput {
    productVariantId: ID!
    quantity: Int!
    currentPrice: Decimal!
    customAttributes: [AttributeInput!]
    sellingPlanId: ID
    sellingPlanName: String
    pricingPolicy: SubscriptionPricingPolicyInput
}

input SubscriptionLineUpdateInput {
    productVariantId: ID
    quantity: Int
    sellingPlanId: ID
    sellingPlanName: String
    currentPrice: Decimal
    customAttributes: [AttributeInput!]
    pricingPolicy: SubscriptionPricingPolicyInput
}

type SubscriptionMailingAddress {
    address1: String
    address2: String
    city: String
    company: String
    country: String
    countryCode: CountryCode
    firstName: String
    lastName: String
    name: String
    phone: String
    province: String
    provinceCode: String
    zip: String
}

type SubscriptionManualDiscount {
    entitledLines: SubscriptionDiscountEntitledLines!
    id: ID!
    recurringCycleLimit: Int
    rejectionReason: SubscriptionDiscountRejectionReason
    targetType: DiscountTargetType!
    title: String
    type: DiscountType!
    usageCount: Int!
    value: SubscriptionDiscountValue!
}

type SubscriptionManualDiscountConnection {
    edges: [SubscriptionManualDiscountEdge!]!
    pageInfo: PageInfo!
}

type SubscriptionManualDiscountEdge {
    cursor: String!
    node: SubscriptionManualDiscount!
}

input SubscriptionManualDiscountEntitledLinesInput {
    all: Boolean
    lines: SubscriptionManualDiscountLinesInput
}

input SubscriptionManualDiscountFixedAmountInput {
    amount: Float
    appliesOnEachItem: Boolean
}

input SubscriptionManualDiscountInput {
    title: String
    value: SubscriptionManualDiscountValueInput
    recurringCycleLimit: Int
    entitledLines: SubscriptionManualDiscountEntitledLinesInput
}

input SubscriptionManualDiscountLinesInput {
    add: [ID!]
    remove: [ID!]
}

input SubscriptionManualDiscountValueInput {
    percentage: Int
    fixedAmount: SubscriptionManualDiscountFixedAmountInput
}

type SubscriptionPricingPolicy {
    basePrice: MoneyV2!
    cycleDiscounts: [SubscriptionCyclePriceAdjustment!]!
}

input SubscriptionPricingPolicyCycleDiscountsInput {
    afterCycle: Int!
    adjustmentType: SellingPlanPricingPolicyAdjustmentType!
    adjustmentValue: SellingPlanPricingPolicyValueInput!
    computedPrice: Decimal!
}

input SubscriptionPricingPolicyInput {
    basePrice: Decimal!
    cycleDiscounts: [SubscriptionPricingPolicyCycleDiscountsInput!]!
}

type SubscriptionShippingOption {
    carrierService: DeliveryCarrierService
    code: String!
    description: String
    phoneRequired: Boolean
    presentmentTitle: String
    price: MoneyV2
    title: String!
}

union SubscriptionShippingOptionResult = SubscriptionShippingOptionResultFailure | SubscriptionShippingOptionResultSuccess

type SubscriptionShippingOptionResultFailure {
    message: String
}

type SubscriptionShippingOptionResultSuccess {
    shippingOptions: [SubscriptionShippingOption!]!
}

type SuggestedOrderTransaction {
    accountNumber: String
    amount: Money! @deprecated(reason: "Use `amountSet` instead")
    amountSet: MoneyBag!
    formattedGateway: String
    gateway: String
    kind: SuggestedOrderTransactionKind!
    maximumRefundable: Money @deprecated(reason: "Use `maximumRefundableSet` instead")
    maximumRefundableSet: MoneyBag
    parentTransaction: OrderTransaction
}

enum SuggestedOrderTransactionKind {
    SUGGESTED_REFUND
}

type SuggestedRefund {
    amount: Money! @deprecated(reason: "Use `amountSet` instead")
    amountSet: MoneyBag!
    discountedSubtotalSet: MoneyBag!
    maximumRefundable: Money! @deprecated(reason: "Use `maximumRefundableSet` instead")
    maximumRefundableSet: MoneyBag!
    refundDuties: [RefundDuty!]!
    refundLineItems: [RefundLineItem!]!
    shipping: ShippingRefund!
    subtotal: Money! @deprecated(reason: "Use `subtotalSet` instead")
    subtotalSet: MoneyBag!
    suggestedTransactions: [SuggestedOrderTransaction!]!
    totalCartDiscountAmountSet: MoneyBag!
    totalDutiesSet: MoneyBag!
    totalTaxSet: MoneyBag!
    totalTaxes: Money! @deprecated(reason: "Use `totalTaxSet` instead")
}

type TagsAddPayload {
    node: Node
    userErrors: [UserError!]!
}

type TagsRemovePayload {
    node: Node
    userErrors: [UserError!]!
}

enum TaxExemption {
    CA_STATUS_CARD_EXEMPTION
    CA_BC_RESELLER_EXEMPTION
    CA_MB_RESELLER_EXEMPTION
    CA_SK_RESELLER_EXEMPTION
    CA_DIPLOMAT_EXEMPTION
    CA_BC_COMMERCIAL_FISHERY_EXEMPTION
    CA_MB_COMMERCIAL_FISHERY_EXEMPTION
    CA_NS_COMMERCIAL_FISHERY_EXEMPTION
    CA_PE_COMMERCIAL_FISHERY_EXEMPTION
    CA_SK_COMMERCIAL_FISHERY_EXEMPTION
    CA_BC_PRODUCTION_AND_MACHINERY_EXEMPTION
    CA_SK_PRODUCTION_AND_MACHINERY_EXEMPTION
    CA_BC_SUB_CONTRACTOR_EXEMPTION
    CA_SK_SUB_CONTRACTOR_EXEMPTION
    CA_BC_CONTRACTOR_EXEMPTION
    CA_SK_CONTRACTOR_EXEMPTION
    CA_ON_PURCHASE_EXEMPTION
    CA_MB_FARMER_EXEMPTION
    CA_NS_FARMER_EXEMPTION
    CA_SK_FARMER_EXEMPTION
}

type TaxLine {
    channelLiable: Boolean
    price: Money! @deprecated(reason: "Use `priceSet` instead")
    priceSet: MoneyBag!
    rate: Float
    ratePercentage: Float
    title: String!
}

type TenderTransaction implements Node {
    amount: MoneyV2!
    id: ID!
    paymentMethod: String
    processedAt: DateTime
    remoteReference: String
    test: Boolean!
    transactionDetails: TenderTransactionDetails
}

type TenderTransactionConnection {
    edges: [TenderTransactionEdge!]!
    pageInfo: PageInfo!
}

type TenderTransactionCreditCardDetails {
    creditCardCompany: String
    creditCardNumber: String
}

union TenderTransactionDetails = TenderTransactionCreditCardDetails

type TenderTransactionEdge {
    cursor: String!
    node: TenderTransaction!
}

type TipSale implements Sale {
    actionType: SaleActionType!
    id: ID!
    lineItem: LineItem!
    lineType: SaleLineType!
    quantity: Int
    taxes: [SaleTax!]!
    totalAmount: MoneyBag!
    totalDiscountAmountAfterTaxes: MoneyBag!
    totalDiscountAmountBeforeTaxes: MoneyBag!
    totalTaxAmount: MoneyBag!
}

input TrackingInfoInput {
    number: String
    url: String
}

input TrackingInfoUpdateInput {
    trackingDetails: [TrackingInfoInput!]
    trackingCompany: String
    notifyCustomer: Boolean
}

type TransactionFee implements Node {
    amount: MoneyV2!
    flatFee: MoneyV2!
    flatFeeName: String
    id: ID!
    rate: Decimal!
    rateName: String
    taxAmount: MoneyV2!
    type: String!
}

type TranslatableContent {
    digest: String
    key: String!
    locale: String!
    value: String
}

type TranslatableResource {
    resourceId: ID!
    translatableContent: [TranslatableContent!]!
    translations(locale: String!, outdated: Boolean): [Translation!]!
}

type TranslatableResourceConnection {
    edges: [TranslatableResourceEdge!]!
    pageInfo: PageInfo!
}

type TranslatableResourceEdge {
    cursor: String!
    node: TranslatableResource!
}

enum TranslatableResourceType {
    PRODUCT
    PRODUCT_VARIANT
    EMAIL_TEMPLATE
    ONLINE_STORE_THEME
    ONLINE_STORE_ARTICLE
    ONLINE_STORE_BLOG
    ONLINE_STORE_PAGE
    COLLECTION
    LINK
    METAFIELD
    SMS_TEMPLATE
    SHOP
    SHOP_POLICY
    PAYMENT_GATEWAY
    PRODUCT_OPTION
    DELIVERY_METHOD_DEFINITION
}

type Translation {
    key: String!
    locale: String!
    outdated: Boolean!
    value: String
}

enum TranslationErrorCode {
    BLANK
    INVALID
    RESOURCE_NOT_FOUND
    TOO_MANY_KEYS_FOR_RESOURCE
    INVALID_KEY_FOR_MODEL
    FAILS_RESOURCE_VALIDATION
    INVALID_TRANSLATABLE_CONTENT
    INVALID_LOCALE_FOR_SHOP
    INVALID_CODE
    INVALID_FORMAT
}

input TranslationInput {
    locale: String!
    key: String!
    value: String!
    translatableContentDigest: String!
}

type TranslationsRegisterPayload {
    translations: [Translation!]
    userErrors: [TranslationUserError!]!
}

type TranslationsRemovePayload {
    translations: [Translation!]
    userErrors: [TranslationUserError!]!
}

type TranslationUserError implements DisplayableError {
    code: TranslationErrorCode
    field: [String!]
    message: String!
}

enum UnitSystem {
    IMPERIAL_SYSTEM
    METRIC_SYSTEM
}

scalar UnsignedInt64

input UpdateMediaInput {
    id: ID!
    previewImageSource: String
    alt: String
}

scalar URL

type UrlRedirect implements Node {
    id: ID!
    path: String!
    target: String!
}

type UrlRedirectBulkDeleteAllPayload {
    job: Job
    userErrors: [UserError!]!
}

type UrlRedirectBulkDeleteByIdsPayload {
    job: Job
    userErrors: [UrlRedirectBulkDeleteByIdsUserError!]!
}

type UrlRedirectBulkDeleteByIdsUserError implements DisplayableError {
    code: UrlRedirectBulkDeleteByIdsUserErrorCode
    field: [String!]
    message: String!
}

enum UrlRedirectBulkDeleteByIdsUserErrorCode {
    IDS_EMPTY
}

type UrlRedirectBulkDeleteBySavedSearchPayload {
    job: Job
    userErrors: [UrlRedirectBulkDeleteBySavedSearchUserError!]!
}

type UrlRedirectBulkDeleteBySavedSearchUserError implements DisplayableError {
    code: UrlRedirectBulkDeleteBySavedSearchUserErrorCode
    field: [String!]
    message: String!
}

enum UrlRedirectBulkDeleteBySavedSearchUserErrorCode {
    SAVED_SEARCH_NOT_FOUND
    INVALID_SAVED_SEARCH_QUERY
}

type UrlRedirectBulkDeleteBySearchPayload {
    job: Job
    userErrors: [UrlRedirectBulkDeleteBySearchUserError!]!
}

type UrlRedirectBulkDeleteBySearchUserError implements DisplayableError {
    code: UrlRedirectBulkDeleteBySearchUserErrorCode
    field: [String!]
    message: String!
}

enum UrlRedirectBulkDeleteBySearchUserErrorCode {
    INVALID_SEARCH_ARGUMENT
}

type UrlRedirectConnection {
    edges: [UrlRedirectEdge!]!
    pageInfo: PageInfo!
}

type UrlRedirectCreatePayload {
    urlRedirect: UrlRedirect
    userErrors: [UrlRedirectUserError!]!
}

type UrlRedirectDeletePayload {
    deletedUrlRedirectId: ID
    userErrors: [UrlRedirectUserError!]!
}

type UrlRedirectEdge {
    cursor: String!
    node: UrlRedirect!
}

enum UrlRedirectErrorCode {
    DOES_NOT_EXIST
    CREATE_FAILED
    UPDATE_FAILED
    DELETE_FAILED
}

type UrlRedirectImport implements Node {
    count: Int
    createdCount: Int
    failedCount: Int
    finished: Boolean!
    finishedAt: DateTime
    id: ID!
    previewRedirects: [UrlRedirectImportPreview!]!
    updatedCount: Int
}

type UrlRedirectImportCreatePayload {
    urlRedirectImport: UrlRedirectImport
    userErrors: [UrlRedirectImportUserError!]!
}

enum UrlRedirectImportErrorCode {
    FILE_DOES_NOT_EXIST
    NOT_FOUND
    ALREADY_IMPORTED
    IN_PROGRESS
}

type UrlRedirectImportPreview {
    path: String!
    target: String!
}

type UrlRedirectImportSubmitPayload {
    job: Job
    userErrors: [UrlRedirectImportUserError!]!
}

type UrlRedirectImportUserError implements DisplayableError {
    code: UrlRedirectImportErrorCode
    field: [String!]
    message: String!
}

input UrlRedirectInput {
    path: String
    target: String
}

enum UrlRedirectSortKeys {
    RELEVANCE
    PATH
    ID
}

type UrlRedirectUpdatePayload {
    urlRedirect: UrlRedirect
    userErrors: [UrlRedirectUserError!]!
}

type UrlRedirectUserError implements DisplayableError {
    code: UrlRedirectErrorCode
    field: [String!]
    message: String!
}

type UserError implements DisplayableError {
    field: [String!]
    message: String!
}

scalar UtcOffset

input UTMInput {
    campaign: String!
    source: String!
    medium: String!
}

type UTMParameters {
    campaign: String
    content: String
    medium: String
    source: String
    term: String
}

type Video implements Node & Media {
    alt: String
    filename: String!
    id: ID!
    mediaContentType: MediaContentType!
    mediaErrors: [MediaError!]!
    originalSource: VideoSource
    preview: MediaPreviewImage
    sources: [VideoSource!]!
    status: MediaStatus!
}

type VideoSource {
    format: String!
    height: Int!
    mimeType: String!
    url: String!
    width: Int!
}

type VoidSession {
    id: ID!
    status: VoidSessionStatus!
}

input VoidSessionRejectionReasonInput {
    code: VoidSessionStatusReasonRejectionCode!
    merchantMessage: String
}

type VoidSessionRejectPayload {
    userErrors: [VoidSessionRejectUserError!]!
    voidSession: VoidSession
}

type VoidSessionRejectUserError implements DisplayableError {
    code: VoidSessionRejectUserErrorCode
    field: [String!]
    message: String!
}

enum VoidSessionRejectUserErrorCode {
    VOID_SESSION_NOT_FOUND
    VOID_SESSION_INVALID_STATE
}

type VoidSessionResolvePayload {
    userErrors: [VoidSessionResolveUserError!]!
    voidSession: VoidSession
}

type VoidSessionResolveUserError implements DisplayableError {
    code: VoidSessionResolveUserErrorCode
    field: [String!]
    message: String!
}

enum VoidSessionResolveUserErrorCode {
    VOID_SESSION_NOT_FOUND
    VOID_SESSION_INVALID_STATE
}

type VoidSessionStatus {
    code: VoidSessionStatusCode!
    reason: VoidSessionStatusReason
}

enum VoidSessionStatusCode {
    REJECTED
    RESOLVED
}

type VoidSessionStatusReason {
    code: VoidSessionStatusReasonRejectionCode!
    merchantMessage: String
}

enum VoidSessionStatusReasonRejectionCode {
    PROCESSING_ERROR
}

type WebhookEventBridgeEndpoint {
    arn: ARN!
}

type WebhookHttpEndpoint {
    callbackUrl: URL!
}

type WebhookPubSubEndpoint {
    pubSubProject: String!
    pubSubTopic: String!
}

type WebhookSubscription implements Node & LegacyInteroperability {
    callbackUrl: URL! @deprecated(reason: "Use `endpoint` instead")
    createdAt: DateTime!
    endpoint: WebhookSubscriptionEndpoint!
    format: WebhookSubscriptionFormat!
    id: ID!
    includeFields: [String!]!
    legacyResourceId: UnsignedInt64!
    metafieldNamespaces: [String!]!
    topic: WebhookSubscriptionTopic!
    updatedAt: DateTime!
}

type WebhookSubscriptionConnection {
    edges: [WebhookSubscriptionEdge!]!
    pageInfo: PageInfo!
}

type WebhookSubscriptionCreatePayload {
    userErrors: [UserError!]!
    webhookSubscription: WebhookSubscription
}

type WebhookSubscriptionDeletePayload {
    deletedWebhookSubscriptionId: ID
    userErrors: [UserError!]!
}

type WebhookSubscriptionEdge {
    cursor: String!
    node: WebhookSubscription!
}

union WebhookSubscriptionEndpoint = WebhookEventBridgeEndpoint | WebhookHttpEndpoint | WebhookPubSubEndpoint

enum WebhookSubscriptionFormat {
    JSON
    XML
}

input WebhookSubscriptionInput {
    callbackUrl: URL
    format: WebhookSubscriptionFormat
    includeFields: [String!]
    metafieldNamespaces: [String!]
}

enum WebhookSubscriptionSortKeys {
    CREATED_AT
    ID
    RELEVANCE
}

enum WebhookSubscriptionTopic {
    APP_UNINSTALLED
    CARTS_CREATE
    CARTS_UPDATE
    CHANNELS_DELETE
    CHECKOUTS_CREATE
    CHECKOUTS_DELETE
    CHECKOUTS_UPDATE
    CUSTOMER_PAYMENT_METHODS_CREATE
    CUSTOMER_PAYMENT_METHODS_UPDATE
    CUSTOMER_PAYMENT_METHODS_REVOKE
    COLLECTION_LISTINGS_ADD
    COLLECTION_LISTINGS_REMOVE
    COLLECTION_LISTINGS_UPDATE
    COLLECTION_PUBLICATIONS_CREATE
    COLLECTION_PUBLICATIONS_DELETE
    COLLECTION_PUBLICATIONS_UPDATE
    COLLECTIONS_CREATE
    COLLECTIONS_DELETE
    COLLECTIONS_UPDATE
    CUSTOMER_GROUPS_CREATE
    CUSTOMER_GROUPS_DELETE
    CUSTOMER_GROUPS_UPDATE
    CUSTOMERS_CREATE
    CUSTOMERS_DELETE
    CUSTOMERS_DISABLE
    CUSTOMERS_ENABLE
    CUSTOMERS_UPDATE
    DISPUTES_CREATE
    DISPUTES_UPDATE
    DRAFT_ORDERS_CREATE
    DRAFT_ORDERS_DELETE
    DRAFT_ORDERS_UPDATE
    FULFILLMENT_EVENTS_CREATE
    FULFILLMENT_EVENTS_DELETE
    FULFILLMENTS_CREATE
    FULFILLMENTS_UPDATE
    ATTRIBUTED_SESSIONS_FIRST
    ATTRIBUTED_SESSIONS_LAST
    ORDER_TRANSACTIONS_CREATE
    ORDERS_CANCELLED
    ORDERS_CREATE
    ORDERS_DELETE
    ORDERS_EDITED
    ORDERS_FULFILLED
    ORDERS_PAID
    ORDERS_PARTIALLY_FULFILLED
    ORDERS_UPDATED
    PRODUCT_LISTINGS_ADD
    PRODUCT_LISTINGS_REMOVE
    PRODUCT_LISTINGS_UPDATE
    PRODUCT_PUBLICATIONS_CREATE
    PRODUCT_PUBLICATIONS_DELETE
    PRODUCT_PUBLICATIONS_UPDATE
    PRODUCTS_CREATE
    PRODUCTS_DELETE
    PRODUCTS_UPDATE
    REFUNDS_CREATE
    SHIPPING_ADDRESSES_CREATE
    SHIPPING_ADDRESSES_UPDATE
    SHOP_UPDATE
    TAX_SERVICES_CREATE
    TAX_SERVICES_UPDATE
    THEMES_CREATE
    THEMES_DELETE
    THEMES_PUBLISH
    THEMES_UPDATE
    VARIANTS_IN_STOCK
    VARIANTS_OUT_OF_STOCK
    INVENTORY_LEVELS_CONNECT
    INVENTORY_LEVELS_UPDATE
    INVENTORY_LEVELS_DISCONNECT
    INVENTORY_ITEMS_CREATE
    INVENTORY_ITEMS_UPDATE
    INVENTORY_ITEMS_DELETE
    LOCATIONS_CREATE
    LOCATIONS_UPDATE
    LOCATIONS_DELETE
    TENDER_TRANSACTIONS_CREATE
    APP_PURCHASES_ONE_TIME_UPDATE
    APP_SUBSCRIPTIONS_UPDATE
    LOCALES_CREATE
    LOCALES_UPDATE
    DOMAINS_CREATE
    DOMAINS_UPDATE
    DOMAINS_DESTROY
    SUBSCRIPTION_CONTRACTS_CREATE
    SUBSCRIPTION_CONTRACTS_UPDATE
    PROFILES_CREATE
    PROFILES_UPDATE
    PROFILES_DELETE
    SUBSCRIPTION_BILLING_ATTEMPTS_SUCCESS
    SUBSCRIPTION_BILLING_ATTEMPTS_FAILURE
}

type WebhookSubscriptionUpdatePayload {
    userErrors: [UserError!]!
    webhookSubscription: WebhookSubscription
}

type Weight {
    unit: WeightUnit!
    value: Float!
}

input WeightInput {
    value: Float!
    unit: WeightUnit!
}

enum WeightUnit {
    KILOGRAMS
    GRAMS
    POUNDS
    OUNCES
}
